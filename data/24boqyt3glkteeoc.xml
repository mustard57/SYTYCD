<message message-id="6464bab0604061324x7ca66a0foa9557418a638ab95@mail.gmail.com" list="com.googlegroups.django-developers" id="24boqyt3glkteeoc" type="development" date="2006-04-06T15:24:14-05:00" year="2006-01-01" year-month="2006-04-01" year-month-day="2006-04-06" thread-id="24boqyt3glkteeoc"><headers><envelope-from-line>Thu Aug 21 13:11:28 2008</envelope-from-line><from personal="Adrian Holovaty" address="holov...@gmail.com">Adrian Holovaty &lt;holov...@gmail.com&gt;</from><to personal="django-developers@googlegroups.com" address="django-developers@googlegroups.com">django-developers@googlegroups.com</to><subject normal="Reverse URL lookup implementation">Reverse URL lookup implementation</subject><received>from srv-117c-be06.markmail.marklogic.com ([172.19.8.46])
          by mail-1.a.markmail.int (JAMES SMTP Server 2.3.1) with SMTP ID 1005
          for &lt;felecia.welch.anderson@a.markmail.org&gt;;
          Thu, 21 Aug 2008 13:11:28 -0700 (PDT)</received><received>from crawl-1.a.markmail.int (slb-117n.markmail.marklogic.com [172.19.8.33])
	by mgw-1.public.markmail.int (Postfix) with ESMTP id 45D472908051
	for &lt;felecia.welch.anderson@a.markmail.org&gt;; Thu, 21 Aug 2008 13:11:28 -0700 (PDT)</received><received>from crawl-1.a.markmail.int (localhost.localdomain [127.0.0.1])
	by crawl-1.a.markmail.int (8.13.8/8.13.8) with ESMTP id m7LKBRF6020202
	for &lt;felecia.welch.anderson@a.markmail.org&gt;; Thu, 21 Aug 2008 13:11:27 -0700</received><received>(from crawler@localhost)
	by crawl-1.a.markmail.int (8.13.8/8.13.8/Submit) id m7LKBRkE020200
	for felecia.welch.anderson@a.markmail.org; Thu, 21 Aug 2008 13:11:27 -0700</received><x-authentication-warning>crawl-1.a.markmail.int: crawler set sender to root@localhost using -r</x-authentication-warning><x-markmail-googlegroups-list>com.googlegroups.django-developers</x-markmail-googlegroups-list><x-markmail-googlegroups-mid>dc752a6cd2f30c90</x-markmail-googlegroups-mid><received>by 10.11.53.59 with SMTP id b59mr2908963cwa;
        Thu, 06 Apr 2006 13:24:18 -0700 (PDT)</received><received>from wproxy.gmail.com (wproxy.gmail.com [64.233.184.224])
        by mx.googlegroups.com with ESMTP id v23si1068761cwb.2006.04.06.13.24.16;
        Thu, 06 Apr 2006 13:24:17 -0700 (PDT)</received><received-spf>pass (googlegroups.com: domain of holov...@gmail.com designates 64.233.184.224 as permitted sender)</received-spf><domainkey-status>good (test mode)</domainkey-status><received>by wproxy.gmail.com with SMTP id 50so236554wri
        for &lt;django-developers@googlegroups.com&gt;; Thu, 06 Apr 2006 13:24:15 -0700 (PDT)</received><domainkey-signature>a=rsa-sha1; q=dns; c=nofws;
        s=beta; d=gmail.com;
        h=received:message-id:date:from:to:subject:mime-version:content-type;
        b=VNlZl/TD2NPt4XBpbUEbzwqCnagcnUcmE0ZnVlZFYCGSI+c/ag8XchAFImdgNXPKQRmjqj4dSkgHwkhOHIrq/ijOfKE4kslHDu3r8qeUDEXDGcB9zmVrlK7QjKyzTUb+SB3fXowQ87WnWQJfG5b1Q4zr9lDaNlQ7yf4lIq0139A=</domainkey-signature><received>by 10.65.137.18 with SMTP id p18mr17687qbn;
        Thu, 06 Apr 2006 13:24:15 -0700 (PDT)</received><received>by 10.65.135.9 with HTTP; Thu, 6 Apr 2006 13:24:14 -0700 (PDT)</received><message-id>6464bab0604061324x7ca66a0foa9557418a638ab95@mail.gmail.com</message-id><date>Thu, 6 Apr 2006 15:24:14 -0500</date><mime-version>1.0</mime-version><content-type>multipart/mixed; 
	boundary="----=_Part_7004_23143760.1144355054418"</content-type></headers><attachments><attachment type="text/x-python" file="urlresolvers.py" size="7924" uri="/24boqyt3glkteeoc/attach00/urlresolvers.py" extension="py"><page page="1"><attachpara>"""
This module converts requested URLs to callback view functions.

RegexURLResolver is the main class here. Its resolve() method takes a URL (as
a string) and returns a tuple in this format:

    (view_function, function_args, function_kwargs)
"""

from django.http import Http404
from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist
import re

class Resolver404(Http404):
    pass

class NoReverseMatch(Exception):
    pass

def get_mod_func(callback):
    # Converts 'django.views.news.stories.story_detail' to
    # ['django.views.news.stories', 'story_detail']
    dot = callback.rindex('.')
    return callback[:dot], callback[dot+1:]

class MatchChecker(object):
    "Class used in reverse RegexURLPattern lookup."
    def __init__(self, args, kwargs):
        self.args, self.kwargs = args, kwargs
        self.current_arg = 0

    def __call__(self, match_obj):
        # match_obj.group(1) is the contents of the parenthesis.
        # First we need to figure out whether it's a named or unnamed group.
        #
        grouped = match_obj.group(1)
        m = re.search(r'^\?P&lt;(\w+)&gt;(.*?)$', grouped)
        if m: # If this was a named group...
            # m.group(1) is the name of the group
            # m.group(2) is the regex.
            try:
                value = self.kwargs[m.group(1)]
            except KeyError:
                # It was a named group, but the arg was passed in as a
                # positional arg or not at all.
                try:
                    value = self.args[self.current_arg]
                    self.current_arg += 1
                except IndexError:
                    # The arg wasn't passed in.
                    raise NoReverseMatch('Not enough positional arguments passed in')
            test_regex = m.group(2)
        else: # Otherwise, this was a positional (unnamed) group.
            try:
                value = self.args[self.current_arg]
                self.current_arg += 1
            except IndexError:
                # The arg wasn't passed in.
                raise NoReverseMatch('Not enough positional arguments passed in')
            test_regex = grouped
        # Note we're using re.match here on purpose because the start of
        # to string needs to match.
        if not re.match(test_regex + '$', str(value)): # TODO: Unicode?
            raise NoReverseMatch("Value %r didn't match regular expression %r" % (value, test_regex))
        return str(value) # TODO: Unicode?

class RegexURLPattern:
    def __init__(self, regex, callback, default_args=None):
        # regex is a string representing a regular expression.
        # callback is something like 'foo.views.news.stories.story_detail',
        # which represents the path to a module and a view function name.
        self.regex = re.compile(regex)
        self.callback = callback
        self.default_args = default_args or {}

    def resolve(self, path):
        match = self.regex.search(path)
        if match:
            # If there are any named groups, use those as kwargs, ignoring
            # non-named groups. Otherwise, pass all non-named arguments as
            # positional arguments.
            kwargs = match.groupdict()
            if kwargs:
                args = ()
            if not kwargs:
                args = match.groups()
            # In both cases, pass any extra_kwargs as **kwargs.
            kwargs.update(self.default_args)

            try: # Lazily load self.func.
                return self.func, args, kwargs
            except AttributeError:
                self.func = self.get_callback()
            return self.func, args, kwargs

    def get_callback(self):
        mod_name, func_name = get_mod_func(self.callback)
        try:
            return getattr(__import__(mod_name, '', '', ['']), func_name)
        except ImportError, e:
            raise ViewDoesNotExist, "Could not import %s. Error was: %s" % (mod_name, str(e))
        except AttributeError, e:
            raise ViewDoesNotExist, "Tried %s in module %s. Error was: %s" % (func_name, mod_name, str(e))

    def reverse(self, viewname, *args, **kwargs):
        if viewname != self.callback:
            raise NoReverseMatch
        return self.reverse_helper(*args, **kwargs)

    def reverse_helper(self, *args, **kwargs):
        """
        Does a "reverse" lookup -- returns the URL for the given args/kwargs.
        The args/kwargs are applied to the regular expression in this
        RegexURLPattern. For example:

            &gt;&gt;&gt; RegexURLPattern('^places/(\d+)/$').reverse_helper(3)
            'places/3/'
            &gt;&gt;&gt; RegexURLPattern('^places/(?P&lt;id&gt;\d+)/$').reverse_helper(id=3)
            'places/3/'
            &gt;&gt;&gt; RegexURLPattern('^people/(?P&lt;state&gt;\w\w)/(\w+)/$').reverse_helper('adrian', state='il')
            'people/il/adrian/'

        Raises NoReverseMatch if the args/kwargs aren't valid for the RegexURLPattern.
        """
        # TODO: Handle nested parenthesis in the following regex.
        result = re.sub(r'\(([^)]+)\)', MatchChecker(args, kwargs), self.regex.pattern)
        return result.replace('^', '').replace('$', '')

class RegexURLResolver(object):
    def __init__(self, regex, urlconf_name):
        # regex is a string representing a regular expression.
        # urlconf_name is a string representing the module containing urlconfs.
        self.regex = re.compile(regex)
        self.urlconf_name = urlconf_name
        self.callback = None

    def resolve(self, path):
        tried = []
        match = self.regex.search(path)
        if match:
            new_path = path[match.end():]
            for pattern in self.urlconf_module.urlpatterns:
                try:
                    sub_match = pattern.resolve(new_path)
                except Resolver404, e:
                    tried.extend([(pattern.regex.pattern + '   ' + t) for t in e.args[0]['tried']])
                else:
                    if sub_match:
                        return sub_match[0], sub_match[1], dict(match.groupdict(), **sub_match[2])
                    tried.append(pattern.regex.pattern)
            raise Resolver404, {'tried': tried, 'path': new_path}

    def _get_urlconf_module(self):
        try:
            return self._urlconf_module
        except AttributeError:
            try:
                self._urlconf_module = __import__(self.urlconf_name, '', '', [''])
            except ValueError, e:
                # Invalid urlconf_name, such as "foo.bar." (note trailing period)
                raise ImproperlyConfigured, "Error while importing URLconf %r: %s" % (self.urlconf_name, e)
            return self._urlconf_module
    urlconf_module = property(_get_urlconf_module)

    def _get_url_patterns(self):
        return self.urlconf_module.urlpatterns
    url_patterns = property(_get_url_patterns)

    def _resolve_special(self, view_type):
        callback = getattr(self.urlconf_module, 'handler%s' % view_type)
        mod_name, func_name = get_mod_func(callback)
        try:
            return getattr(__import__(mod_name, '', '', ['']), func_name), {}
        except (ImportError, AttributeError), e:
            raise ViewDoesNotExist, "Tried %s. Error was: %s" % (callback, str(e))

    def resolve404(self):
        return self._resolve_special('404')

    def resolve500(self):
        return self._resolve_special('500')

    def reverse(self, viewname, *args, **kwargs):
        for pattern in self.urlconf_module.urlpatterns:
            if pattern.callback == viewname:
                try:
                    return pattern.reverse_helper(*args, **kwargs)
                except NoReverseMatch:
                    continue
        raise NoReverseMatch
</attachpara></page></attachment><attachment type="text/x-python" file="reverse_unit_tests.py" size="2146" uri="/24boqyt3glkteeoc/attach01/reverse_unit_tests.py" extension="py"><page page="1"><attachpara>"Unit tests for reverse URL lookup"

from django.core.urlresolvers import RegexURLPattern, NoReverseMatch
import re

test_data = (
    ('^places/(\d+)/$', 'places/3/', [3], {}),
    ('^places/(\d+)/$', 'places/3/', ['3'], {}),
    ('^places/(\d+)/$', NoReverseMatch, ['a'], {}),
    ('^places/(\d+)/$', NoReverseMatch, [], {}),
    ('^places/(?P&lt;id&gt;\d+)/$', 'places/3/', [], {'id': 3}),
    ('^people/(?P&lt;name&gt;\w+)/$', 'people/adrian/', ['adrian'], {}),
    ('^people/(?P&lt;name&gt;\w+)/$', 'people/adrian/', [], {'name': 'adrian'}),
    ('^people/(?P&lt;name&gt;\w+)/$', NoReverseMatch, ['name with spaces'], {}),
    ('^people/(?P&lt;name&gt;\w+)/$', NoReverseMatch, [], {'name': 'name with spaces'}),
    ('^people/(?P&lt;name&gt;\w+)/$', NoReverseMatch, [], {}),
    ('^hardcoded/$', 'hardcoded/', [], {}),
    ('^hardcoded/$', 'hardcoded/', ['any arg'], {}),
    ('^hardcoded/$', 'hardcoded/', [], {'kwarg': 'foo'}),
    ('^people/(?P&lt;state&gt;\w\w)/(?P&lt;name&gt;\w+)/$', 'people/il/adrian/', [], {'state': 'il', 'name': 'adrian'}),
    ('^people/(?P&lt;state&gt;\w\w)/(?P&lt;name&gt;\d)/$', NoReverseMatch, [], {'state': 'il', 'name': 'adrian'}),
    ('^people/(?P&lt;state&gt;\w\w)/(?P&lt;name&gt;\w+)/$', NoReverseMatch, [], {'state': 'il'}),
    ('^people/(?P&lt;state&gt;\w\w)/(?P&lt;name&gt;\w+)/$', NoReverseMatch, [], {'name': 'adrian'}),
    ('^people/(?P&lt;state&gt;\w\w)/(\w+)/$', NoReverseMatch, ['il'], {'name': 'adrian'}),
    ('^people/(?P&lt;state&gt;\w\w)/(\w+)/$', 'people/il/adrian/', ['adrian'], {'state': 'il'}),
)

def run_tests():
    for i, (regex, expected, args, kwargs) in enumerate(test_data):
        pat = RegexURLPattern(regex, 'foo')
        passed = True
        try:
            got = pat.url(*args, **kwargs)
        except NoReverseMatch, e:
            if expected != NoReverseMatch:
                passed, got = False, str(e)
        else:
            if got != expected:
                passed, got = False, got
        print "Test %s: %s" % (i+1, passed and 'passed' or 'FAILED')
        if not passed:
            print "   Got: %s" % got
            print "   Expected: %r" % expected

if __name__ == "__main__":
    run_tests()
</attachpara></page></attachment></attachments><normalized-references><normalized-message-id>6464bab0604061324x7ca66a0foa9557418a638ab95@mail.gmail.com</normalized-message-id></normalized-references><body><para depth="0">On the plane from London to Chicago yesterday, I implemented something
that's been discussed on this list lately -- "reverse" URL creation.

</para><para depth="0">I've attached a new urlresolvers.py to this e-mail. It's intended to
replace the one in django/core, and it works with magic-removal only.
(To use it with trunk, just replace the import line at the top to
import Http404 from django.core.exceptions instead of django.http.)
I've also attached unit tests.

</para><para depth="0">Given a view name (e.g. 'myproject.polls.views.poll_detail', as a
string) and any number of positional or keyword arguments, this code
generates the URL according to the first URL pattern in your URLconf
that matches.

</para><para depth="0">The method is reverse() on both the RegexURLPattern and
RegexURLResolver classes.

</para><para depth="0">Here's an example of how it works. Given this root URLconf:

</para><para depth="0">urlpatterns = patterns('',
    (r'^foo/$', 'path.to.foo_view'),
    (r'^dates/(\d{4})/(\w{3})/$', 'path.to.month_view'),
    (r'^people/(?P&lt;state&gt;\w\w)/(?P&lt;name&gt;\w+)/$', 'path.to.person_view'),
)

</para><para depth="0">Here's how to use it:

</para><quote depth="1"><quote depth="2"><quote depth="3"><quotepara depth="3">from django.conf import settings
from django.core import urlresolvers
resolver = urlresolvers.RegexURLResolver(r'^/', settings.ROOT_URLCONF)
resolver.reverse('path.to.foo_view')
'foo/'
resolver.reverse('path.to.month_view', '2005', 'apr')
'dates/2005/apr/'
resolver.reverse('path.to.person_view', state='il', name='adrian')
'people/il/adrian/'
resolver.reverse('path.to.person_view', 'il', 'adrian')
</quotepara></quote></quote></quote><para depth="0">'people/il/adrian/'
# In the following, 'invalidstate' fails the regex test (it isn't two
characters long).
</para><quote depth="1"><quote depth="2"><quote depth="3"><quotepara depth="3">resolver.reverse('path.to.person_view', 'invalidstate', 'adrian')
</quotepara></quote></quote></quote><para depth="0">Traceback (most recent call last):
...
NoReverseMatch

</para><para depth="0">Ideally there'd be a template-tag interface to this. Something like:

</para><para depth="0">    {% link 'path.to.month_view' 2005 'apr' %}
    {% link 'path.to.person_view' state='il' name='adrian' %}

</para><para depth="0">It's implemented by analyzing the regular expression, which was quite
fun. This means it'll probably break for wacky regexes, but I think a
95% solution is fine.

</para><para depth="0">Thoughts?

</para><para depth="0">Adrian

</para><footer type="signature" depth="0" hash="15061906421678913248">--
Adrian Holovaty
holovaty.com | djangoproject.com
</footer></body></message>