<message message-id="2fb4a5011003031557n70e73548y8513da53232bd4fc@mail.gmail.com" list="com.enthought.mail.enthought-dev" id="24ce4mjjjue7jvro" type="development" date="2010-03-03T15:57:00.138641-08:00" year="2010-01-01" year-month="2010-03-01" year-month-day="2010-03-03" thread-id="5jpxq5ei6z3nusjq"><headers><envelope-from-line>Wed Mar 03 15:57:23 2010</envelope-from-line><from personal="robert somerville" address="rbrt.somerville@gmail.com">robert somerville &lt;rbrt.somerville@gmail.com&gt;</from><to personal="enthought-dev" address="enthought-dev@enthought.com">enthought-dev &lt;enthought-dev@enthought.com&gt;</to><subject normal="[Enthought-Dev] new build of Enthought 3.4 and Problems">[Enthought-Dev] new build of Enthought 3.4 and Problems</subject><received>from srv-117c-be06.markmail.marklogic.com ([172.19.8.46])
          by mail-1.a.markmail.int (JAMES SMTP Server 2.3.1) with SMTP ID 369
          for &lt;freda.bradshaw.whitaker@a.markmail.org&gt;;
          Wed, 3 Mar 2010 15:57:22 -0800 (GMT-08:00)</received><received>from mail.enthought.com (slb-117n.markmail.marklogic.com [172.19.8.33])
	by mgw-1.public.markmail.int (Postfix) with ESMTP id 81220290833D
	for &lt;freda.bradshaw.whitaker@a.markmail.org&gt;; Wed,  3 Mar 2010 15:56:58 -0800 (PST)</received><received>from mail.enthought.com (localhost.localdomain [127.0.0.1])
	by mail.enthought.com (Postfix) with ESMTP id D1C0EB7DC5;
	Wed,  3 Mar 2010 18:47:08 -0600 (CST)</received><x-original-to>enthought-dev@enthought.com</x-original-to><delivered-to>enthought-dev@enthought.com</delivered-to><received>from smtp.enthought.com (smtp.enthought [10.2.0.35])
	by mail.enthought.com (Postfix) with ESMTP id B0F1BB78BE
	for &lt;enthought-dev@enthought.com&gt;; Wed,  3 Mar 2010 18:47:06 -0600 (CST)</received><x-asg-debug-id>1267660632-575902570001-WrEhBw</x-asg-debug-id><received>from mail-fx0-f224.google.com (mail-fx0-f224.google.com
	[209.85.220.224]) by smtp.enthought.com with ESMTP id
	Eokur6UImkgleRPw for &lt;enthought-dev@enthought.com&gt;;
	Wed, 03 Mar 2010 17:57:12 -0600 (CST)</received><x-barracuda-envelope-from>rbrt.somerville@gmail.com</x-barracuda-envelope-from><x-barracuda-rbl-trusted-forwarder>209.85.220.224</x-barracuda-rbl-trusted-forwarder><received>by fxm24 with SMTP id 24so2396432fxm.37
	for &lt;enthought-dev@enthought.com&gt;; Wed, 03 Mar 2010 15:57:11 -0800 (PST)</received><x-barracuda-bwl-ip>nil</x-barracuda-bwl-ip><x-barracuda-bbl-ip>nil</x-barracuda-bbl-ip><mime-version>1.0</mime-version><received>by 10.102.214.19 with SMTP id m19mr6909412mug.96.1267660631307; Wed, 
	03 Mar 2010 15:57:11 -0800 (PST)</received><date>Wed, 3 Mar 2010 15:57:11 -0800</date><message-id>2fb4a5011003031557n70e73548y8513da53232bd4fc@mail.gmail.com</message-id><x-asg-orig-subj>new build of Enthought 3.4 and Problems</x-asg-orig-subj><content-type>multipart/mixed; boundary=00163642734d9ff9ad0480ee3d1f</content-type><x-barracuda-connect>mail-fx0-f224.google.com[209.85.220.224]</x-barracuda-connect><x-barracuda-start-time>1267660632</x-barracuda-start-time><x-barracuda-url>http://quarantine.enthought.com:80/cgi-mod/mark.cgi</x-barracuda-url><x-virus-scanned>by bsmtpd at enthought.com</x-virus-scanned><x-barracuda-spam-score>0.00</x-barracuda-spam-score><x-barracuda-spam-status>No, SCORE=0.00 using global scores of TAG_LEVEL=3.5
	QUARANTINE_LEVEL=6.0 KILL_LEVEL=1000.0 tests=HTML_MESSAGE</x-barracuda-spam-status><x-barracuda-spam-report>Code version 3.2, rules version 3.2.2.19671
	Rule breakdown below
	pts rule name              description
	---- ----------------------
	--------------------------------------------------
	0.00 HTML_MESSAGE           BODY: HTML included in message</x-barracuda-spam-report><x-beenthere>enthought-dev@enthought.com</x-beenthere><x-mailman-version>2.1.9</x-mailman-version><precedence>list</precedence><reply-to>enthought-dev@enthought.com</reply-to><list-id>&lt;enthought-dev.enthought.com&gt;</list-id><list-unsubscribe>&lt;https://mail.enthought.com/mailman/listinfo/enthought-dev&gt;, 
	&lt;mailto:enthought-dev-request@enthought.com?subject=unsubscribe&gt;</list-unsubscribe><list-archive>&lt;http://mail.enthought.com/pipermail/enthought-dev&gt;</list-archive><list-post>&lt;mailto:enthought-dev@enthought.com&gt;</list-post><list-help>&lt;mailto:enthought-dev-request@enthought.com?subject=help&gt;</list-help><list-subscribe>&lt;https://mail.enthought.com/mailman/listinfo/enthought-dev&gt;,
	&lt;mailto:enthought-dev-request@enthought.com?subject=subscribe&gt;</list-subscribe><sender>enthought-dev-bounces@enthought.com</sender><errors-to>enthought-dev-bounces@enthought.com</errors-to></headers><attachments><attachment type="text/x-python" file="site.py" size="25608" uri="/24ce4mjjjue7jvro/attach00/site.py" extension="py"><page page="1"><attachpara>"""Append module search paths for third-party packages to sys.path.

****************************************************************
* This module is automatically imported during initialization. *
****************************************************************

In earlier versions of Python (up to 1.5a3), scripts or modules that
needed to use site-specific modules would place ``import site''
somewhere near the top of their code.  Because of the automatic
import, this is no longer necessary (but code that does it still
works).

This will append site-specific paths to the module search path.  On
Unix (including Mac OSX), it starts with sys.prefix and
sys.exec_prefix (if different) and appends
lib/python&lt;version&gt;/site-packages as well as lib/site-python.
On other platforms (such as Windows), it tries each of the
prefixes directly, as well as with lib/site-packages appended.  The
resulting directories, if they exist, are appended to sys.path, and
also inspected for path configuration files.

For Debian and derivatives, this sys.path is augmented with directories
for packages distributed within the distribution. Local addons go
into /usr/local/lib/python&lt;version&gt;/dist-packages, Debian addons
install into /usr/{lib,share}/python&lt;version&gt;/dist-packages.
/usr/lib/python&lt;version&gt;/site-packages is not used.

A path configuration file is a file whose name has the form
&lt;package&gt;.pth; its contents are additional directories (one per line)
to be added to sys.path.  Non-existing directories (or
non-directories) are never added to sys.path; no directory is added to
sys.path more than once.  Blank lines and lines beginning with
'#' are skipped. Lines starting with 'import' are executed.

For example, suppose sys.prefix and sys.exec_prefix are set to
/usr/local and there is a directory /usr/local/lib/python2.5/site-packages
with three subdirectories, foo, bar and spam, and two path
configuration files, foo.pth and bar.pth.  Assume foo.pth contains the
following:

  # foo package configuration
  foo
  bar
  bletch

and bar.pth contains:

  # bar package configuration
  bar

Then the following directories are added to sys.path, in this order:

  /usr/local/lib/python2.5/site-packages/bar
  /usr/local/lib/python2.5/site-packages/foo

Note that bletch is omitted because it doesn't exist; bar precedes foo
because bar.pth comes alphabetically before foo.pth; and spam is
omitted because it is not mentioned in either path configuration file.

After these path manipulations, an attempt is made to import a module
named sitecustomize, which can perform arbitrary additional
site-specific customizations.  If this import fails with an
ImportError exception, it is silently ignored.

"""

import sys
import os
import __builtin__

# Prefixes for site-packages; add additional prefixes like /usr/local here
PREFIXES = [sys.prefix, sys.exec_prefix]
# Enable per user site-packages directory
# set it to False to disable the feature or True to force the feature
ENABLE_USER_SITE = None
# for distutils.commands.install
USER_SITE = None
USER_BASE = None


def makepath(*paths):
    dir = os.path.abspath(os.path.join(*paths))
    return dir, os.path.normcase(dir)


def abs__file__():
    """Set all module' __file__ attribute to an absolute path"""
    for m in sys.modules.values():
        if hasattr(m, '__loader__'):
            continue   # don't mess with a PEP 302-supplied __file__
        try:
            m.__file__ = os.path.abspath(m.__file__)
        except AttributeError:
            continue


def removeduppaths():
    """ Remove duplicate entries from sys.path along with making them
    absolute"""
    # This ensures that the initial path provided by the interpreter contains
    # only absolute pathnames, even if we're running from the build directory.
    L = []
    known_paths = set()
    for dir in sys.path:
        # Filter out duplicate paths (on case-insensitive file systems also
        # if they only differ in case); turn relative paths into absolute
        # paths.
        dir, dircase = makepath(dir)
        if not dircase in known_paths:
            L.append(dir)
            known_paths.add(dircase)
    sys.path[:] = L
    return known_paths

def _init_pathinfo():
    """Return a set containing all existing directory entries from sys.path"""
    d = set()
    for dir in sys.path:
        try:
            if os.path.isdir(dir):
                dir, dircase = makepath(dir)
                d.add(dircase)
        except TypeError:
            continue
    return d


def addpackage(sitedir, name, known_paths):
    """Process a .pth file within the site-packages directory:
       For each line in the file, either combine it with sitedir to a path
       and add that to known_paths, or execute it if it starts with 'import '.
    """
    if known_paths is None:
        _init_pathinfo()
        reset = 1
    else:
        reset = 0
    fullname = os.path.join(sitedir, name)
    try:
        f = open(fullname, "rU")
    except IOError:
        return
    with f:
        for line in f:
            if line.startswith("#"):
                continue
            if line.startswith(("import ", "import\t")):
                exec line
                continue
            line = line.rstrip()
            dir, dircase = makepath(sitedir, line)
            if not dircase in known_paths and os.path.exists(dir):
                sys.path.append(dir)
                known_paths.add(dircase)
    if reset:
        known_paths = None
    return known_paths


def addsitedir(sitedir, known_paths=None):
    """Add 'sitedir' argument to sys.path if missing and handle .pth files in
    'sitedir'"""
    if known_paths is None:
        known_paths = _init_pathinfo()
        reset = 1
    else:
        reset = 0
    sitedir, sitedircase = makepath(sitedir)
    if not sitedircase in known_paths:
        sys.path.append(sitedir)        # Add path component
    try:
        names = os.listdir(sitedir)
    except os.error:
        return
    dotpth = os.extsep + "pth"
    names = [name for name in names if name.endswith(dotpth)]
    for name in sorted(names):
        addpackage(sitedir, name, known_paths)
    if reset:
        known_paths = None
    return known_paths


def check_enableusersite():
    """Check if user site directory is safe for inclusion

    The function tests for the command line flag (including environment var),
    process uid/gid equal to effective uid/gid.

    None: Disabled for security reasons
    False: Disabled by user (command line option)
    True: Safe and enabled
    """
    if sys.flags.no_user_site:
        return False

    if hasattr(os, "getuid") and hasattr(os, "geteuid"):
        # check process uid == effective uid
        if os.geteuid() != os.getuid():
            return None
    if hasattr(os, "getgid") and hasattr(os, "getegid"):
        # check process gid == effective gid
        if os.getegid() != os.getgid():
            return None

    return True


def addusersitepackages(known_paths):
    """Add a per user site-package to sys.path

    Each user has its own python directory with site-packages in the
    home directory.

    USER_BASE is the root directory for all Python versions

    USER_SITE is the user specific site-packages directory

    USER_SITE/.. can be used for data.
    """
    global USER_BASE, USER_SITE, ENABLE_USER_SITE
    env_base = os.environ.get("PYTHONUSERBASE", None)

    def joinuser(*args):
        return os.path.expanduser(os.path.join(*args))

    #if sys.platform in ('os2emx', 'riscos'):
    #    # Don't know what to put here
    #    USER_BASE = ''
    #    USER_SITE = ''
    if os.name == "nt":
        base = os.environ.get("APPDATA") or "~"
        USER_BASE = env_base if env_base else joinuser(base, "Python")
        USER_SITE = os.path.join(USER_BASE,
                                 "Python" + sys.version[0] + sys.version[2],
                                 "site-packages")
    else:
        USER_BASE = env_base if env_base else joinuser("~", ".local")
        USER_SITE = os.path.join(USER_BASE, "lib",
                                 "python" + sys.version[:3],
                                 "site-packages")

    if ENABLE_USER_SITE and os.path.isdir(USER_SITE):
        addsitedir(USER_SITE, known_paths)
    if ENABLE_USER_SITE:
        for dist_libdir in ("lib", "local/lib"):
            user_site = os.path.join(USER_BASE, dist_libdir,
                                     "python" + sys.version[:3],
                                     "dist-packages")
            if os.path.isdir(user_site):
                addsitedir(user_site, known_paths)
    return known_paths


def addsitepackages(known_paths):
    """Add site-packages (and possibly site-python) to sys.path"""
    sitedirs = []
    seen = []

    for prefix in PREFIXES:
        if not prefix or prefix in seen:
            continue
        seen.append(prefix)

        if sys.platform in ('os2emx', 'riscos'):
            sitedirs.append(os.path.join(prefix, "Lib", "site-packages"))
        elif os.sep == '/':
            sitedirs.append(os.path.join(prefix, "lib",
                                        "python" + sys.version[:3],
                                        "dist-packages"))
            sitedirs.append(os.path.join(prefix, "local/lib",
                                        "python" + sys.version[:3],
                                        "dist-packages"))
            sitedirs.append(os.path.join(prefix, "lib", "dist-python"))
        else:
            sitedirs.append(prefix)
            sitedirs.append(os.path.join(prefix, "lib", "site-packages"))

        if sys.platform == "darwin":
            # for framework builds *only* we add the standard Apple
            # locations. Currently only per-user, but /Library and
            # /Network/Library could be added too
            if 'Python.framework' in prefix:
                sitedirs.append(
                    os.path.expanduser(
                        os.path.join("~", "Library", "Python",
                                     sys.version[:3], "site-packages")))

    for sitedir in sitedirs:
        if os.path.isdir(sitedir):
            addsitedir(sitedir, known_paths)

    return known_paths


def setBEGINLIBPATH():
    """The OS/2 EMX port has optional extension modules that do double duty
    as DLLs (and must use the .DLL file extension) for other extensions.
    The library search path needs to be amended so these will be found
    during module import.  Use BEGINLIBPATH so that these are at the start
    of the library search path.

    """
    dllpath = os.path.join(sys.prefix, "Lib", "lib-dynload")
    libpath = os.environ['BEGINLIBPATH'].split(';')
    if libpath[-1]:
        libpath.append(dllpath)
    else:
        libpath[-1] = dllpath
    os.environ['BEGINLIBPATH'] = ';'.join(libpath)


def setquit():
    """Define new built-ins 'quit' and 'exit'.
    These are simply strings that display a hint on how to exit.

    """
    if os.sep == ':':
        eof = 'Cmd-Q'
    elif os.sep == '\\':
        eof = 'Ctrl-Z plus Return'
    else:
        eof = 'Ctrl-D (i.e. EOF)'

    class Quitter(object):
        def __init__(self, name):
            self.name = name
        def __repr__(self):
            return 'Use %s() or %s to exit' % (self.name, eof)
        def __call__(self, code=None):
            # Shells like IDLE catch the SystemExit, but listen when their
            # stdin wrapper is closed.
            try:
                sys.stdin.close()
            except:
                pass
            raise SystemExit(code)
    __builtin__.quit = Quitter('quit')
    __builtin__.exit = Quitter('exit')


class _Printer(object):
    """interactive prompt objects for printing the license text, a list of
    contributors and the copyright notice."""

    MAXLINES = 23

    def __init__(self, name, data, files=(), dirs=()):
        self.__name = name
        self.__data = data
        self.__files = files
        self.__dirs = dirs
        self.__lines = None

    def __setup(self):
        if self.__lines:
            return
        data = None
        for dir in self.__dirs:
            for filename in self.__files:
                filename = os.path.join(dir, filename)
                try:
                    fp = file(filename, "rU")
                    data = fp.read()
                    fp.close()
                    break
                except IOError:
                    pass
            if data:
                break
        if not data:
            data = self.__data
        self.__lines = data.split('\n')
        self.__linecnt = len(self.__lines)

    def __repr__(self):
        self.__setup()
        if len(self.__lines) &lt;= self.MAXLINES:
            return "\n".join(self.__lines)
        else:
            return "Type %s() to see the full %s text" % ((self.__name,)*2)

    def __call__(self):
        self.__setup()
        prompt = 'Hit Return for more, or q (and Return) to quit: '
        lineno = 0
        while 1:
            try:
                for i in range(lineno, lineno + self.MAXLINES):
                    print self.__lines[i]
            except IndexError:
                break
            else:
                lineno += self.MAXLINES
                key = None
                while key is None:
                    key = raw_input(prompt)
                    if key not in ('', 'q'):
                        key = None
                if key == 'q':
                    break

def setcopyright():
    """Set 'copyright' and 'credits' in __builtin__"""
    __builtin__.copyright = _Printer("copyright", sys.copyright)
    if sys.platform[:4] == 'java':
        __builtin__.credits = _Printer(
            "credits",
            "Jython is maintained by the Jython developers (www.jython.org).")
    else:
        __builtin__.credits = _Printer("credits", """\
    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information.""")
    here = os.path.dirname(os.__file__)
    __builtin__.license = _Printer(
        "license", "See http://www.python.org/%.3s/license.html" % sys.version,
        ["LICENSE.txt", "LICENSE"],
        [os.path.join(here, os.pardir), here, os.curdir])


class _Helper(object):
    """Define the built-in 'help'.
    This is a wrapper around pydoc.help (with a twist).

    """

    def __repr__(self):
        return "Type help() for interactive help, " \
               "or help(object) for help about object."
    def __call__(self, *args, **kwds):
        import pydoc
        return pydoc.help(*args, **kwds)

def sethelper():
    __builtin__.help = _Helper()

def aliasmbcs():
    """On Windows, some default encodings are not provided by Python,
    while they are always available as "mbcs" in each locale. Make
    them usable by aliasing to "mbcs" in such a case."""
    if sys.platform == 'win32':
        import locale, codecs
        enc = locale.getdefaultlocale()[1]
        if enc.startswith('cp'):            # "cp***" ?
            try:
                codecs.lookup(enc)
            except LookupError:
                import encodings
                encodings._cache[enc] = encodings._unknown
                encodings.aliases.aliases[enc] = 'mbcs'

def setencoding():
    """Set the string encoding used by the Unicode implementation.  The
    default is 'ascii', but if you're willing to experiment, you can
    change this."""
    encoding = "ascii" # Default value set by _PyUnicode_Init()
    if 0:
        # Enable to support locale aware default string encodings.
        import locale
        loc = locale.getdefaultlocale()
        if loc[1]:
            encoding = loc[1]
    if 0:
        # Enable to switch off string to Unicode coercion and implicit
        # Unicode to string conversion.
        encoding = "undefined"
    if encoding != "ascii":
        # On Non-Unicode builds this will raise an AttributeError...
        sys.setdefaultencoding(encoding) # Needs Python Unicode build !


def execsitecustomize():
    """Run custom site specific code, if available."""
    try:
        import sitecustomize
    except ImportError:
        pass


def execusercustomize():
    """Run custom user specific code, if available."""
    try:
        import usercustomize
    except ImportError:
        pass


def main():
    global ENABLE_USER_SITE

    abs__file__()
    known_paths = removeduppaths()
    if ENABLE_USER_SITE is None:
        ENABLE_USER_SITE = check_enableusersite()
    known_paths = addusersitepackages(known_paths)
    known_paths = addsitepackages(known_paths)
    if sys.platform == 'os2emx':
        setBEGINLIBPATH()
    setquit()
    setcopyright()
    sethelper()
    aliasmbcs()
    setencoding()
    execsitecustomize()
    if ENABLE_USER_SITE:
        execusercustomize()
    # Remove sys.setdefaultencoding() so that users cannot change the
    # encoding after initialization.  The test for presence is needed when
    # this module is run as a script, because this code is executed twice.
    if hasattr(sys, "setdefaultencoding"):
        del sys.setdefaultencoding

main()

def _script():
    help = """\
    %s [--user-base] [--user-site]

    Without arguments print some useful information
    With arguments print the value of USER_BASE and/or USER_SITE separated
    by '%s'.

    Exit codes with --user-base or --user-site:
      0 - user site directory is enabled
      1 - user site directory is disabled by user
      2 - uses site directory is disabled by super user
          or for security reasons
     &gt;2 - unknown error
    """
    args = sys.argv[1:]
    if not args:
        print "sys.path = ["
        for dir in sys.path:
            print "    %r," % (dir,)
        print "]"
        print "USER_BASE: %r (%s)" % (USER_BASE,
            "exists" if os.path.isdir(USER_BASE) else "doesn't exist")
        print "USER_SITE: %r (%s)" % (USER_SITE,
            "exists" if os.path.isdir(USER_SITE) else "doesn't exist")
        print "ENABLE_USER_SITE: %r" %  ENABLE_USER_SITE
        sys.exit(0)

    buffer = []
    if '--user-base' in args:
        buffer.append(USER_BASE)
    if '--user-site' in args:
        buffer.append(USER_SITE)

    if buffer:
        print os.pathsep.join(buffer)
        if ENABLE_USER_SITE:
            sys.exit(0)
        elif ENABLE_USER_SITE is False:
            sys.exit(1)
        elif ENABLE_USER_SITE is None:
            sys.exit(2)
        else:
            sys.exit(3)
    else:
        import textwrap
        print textwrap.dedent(help % (sys.argv[0], os.pathsep))
        sys.exit(10)

if __name__ == '__main__':
    _script()
</attachpara></page></attachment></attachments><normalized-references><normalized-message-id>2fb4a5011003031557n70e73548y8513da53232bd4fc@mail.gmail.com</normalized-message-id></normalized-references><body><para depth="0">rsomerville@vboxUbuntu910:~$ python
Python 2.6.4rc2 (r264rc2:75497, Oct 20 2009, 02:54:09)
[GCC 4.4.1] on linux2
Type "help", "copyright", "credits" or "license" for more information.
</para><quote depth="1"><quote depth="2"><quote depth="3"><quotepara depth="3">import enthought
import enthought.chaco
</quotepara></quote></quote></quote><para depth="0">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: No module named chaco

</para><para depth="0">rsomerville@vboxUbuntu910:~$ which easy_install
/usr/local/eth/bin/easy_install

</para><para depth="0">I have no installed Enthought packages (via Synaptic ... )

</para><para depth="0">in terms of "sys.path" i find nothing anywhere, the closest i have on
/usr/local is something called "site.py" , below:
rsomerville@vboxUbuntu910:/usr$ find /usr -name "*path" -ls
***********************************************************************
see below this for site.py (sorry for clutter ...)
***********************************************************************
280333    4 drwxr-xr-x   2 root     root         4096 Oct 27 11:01
/usr/share/doc/iputils-tracepath
295119    4 -rw-r--r--   1 root     root         1665 Oct  7 14:26
/usr/share/gconf/default.path
266240    4 -rwxr-xr-x   1 root     root         2643 Oct 22 17:56
/usr/lib/openoffice/program/java-set-classpath
137584    4 -rw-r--r--   1 root     root           74 Mar  2 14:27
/usr/lib/pymodules/python2.6/.path
135310   56 -rwxr-xr-x   1 root     root        56224 Aug 31  2009
/usr/lib/gimp/2.0/plug-ins/selection-to-path
363374    4 drwxr-xr-x   2 root     root         4096 Oct 27 11:16
/usr/src/linux-headers-2.6.31-14-generic/include/config/dm/multipath
357464    4 drwxr-xr-x   2 root     root         4096 Oct 27 11:16
/usr/src/linux-headers-2.6.31-14/drivers/infiniband/hw/ipath
  3329    0 lrwxrwxrwx   1 root     root           21 Feb  5 13:19
/usr/bin/scrollkeeper-get-index-from-docpath -&gt; rarian-sk-get-scripts
  3621    8 -rwxr-xr-x   1 root     root         4965 Oct 28  2004
/usr/bin/xpath
  3330    0 lrwxrwxrwx   1 root     root           21 Feb  5 13:19
/usr/bin/scrollkeeper-get-toc-from-docpath -&gt; rarian-sk-get-scripts
  3007   84 -rwxr-xr-x   1 root     root        85432 Sep  7 03:19
/usr/bin/manpath
  3466   16 -rwxr-xr-x   1 root     root        14544 May 11  2009
/usr/bin/tracepath

</para><para depth="0">rsomerville@vboxUbuntu910:/usr/local$ m
./eth/lib/python2.6/site-packages/site.py
def __boot():
    import sys, imp, os, os.path
    PYTHONPATH = os.environ.get('PYTHONPATH')
    if PYTHONPATH is None or (sys.platform=='win32' and not PYTHONPATH):
        PYTHONPATH = []
    else:
        PYTHONPATH = PYTHONPATH.split(os.pathsep)

</para><para depth="0">    pic = getattr(sys,'path_importer_cache',{})
    stdpath = sys.path[len(PYTHONPATH):]
    mydir = os.path.dirname(__file__)
    #print "searching",stdpath,sys.path

</para><para depth="0">    for item in stdpath:
        if item==mydir or not item:
            continue    # skip if current dir. on Windows, or my own
directory
        importer = pic.get(item)
        if importer is not None:
            loader = importer.find_module('site')
            if loader is not None:
                # This should actually reload the current module
                loader.load_module('site')
                break
        else:
            try:
                stream, path, descr = imp.find_module('site',[item])
            except ImportError:
                continue
            if stream is None:
                continue
            try:
                # This should actually reload the current module
                imp.load_module('site',stream,path,descr)
            finally:
                stream.close()
            break
    else:
        raise ImportError("Couldn't find the real 'site' module")

</para><para depth="0">    #print "loaded", __file__

</para><para depth="0">    known_paths = dict([(makepath(item)[1],1) for item in sys.path]) # 2.2
comp

</para><para depth="0">    oldpos = getattr(sys,'__egginsert',0)   # save old insertion position
    sys.__egginsert = 0                     # and reset the current one

</para><para depth="0">    for item in PYTHONPATH:
        addsitedir(item)

</para><para depth="0">    sys.__egginsert += oldpos           # restore effective old position

</para><para depth="0">    d,nd = makepath(stdpath[0])
    insert_at = None
    new_path = []

</para><para depth="0">    for item in sys.path:
        p,np = makepath(item)

</para><para depth="0">        if np==nd and insert_at is None:
            # We've hit the first 'system' path entry, so added entries go
here
            insert_at = len(new_path)

</para><para depth="0">        if np in known_paths or insert_at is None:
            new_path.append(item)
        else:
            # new path after the insert point, back-insert it
            new_path.insert(insert_at, item)
            insert_at += 1

</para><para depth="0">    sys.path[:] = new_path

</para><para depth="0">if __name__=='site':
    __boot()
    del __boot

</para><para depth="0">IN THE STANDARD PYTHON directory /usr/lib/python2.6, i have the attached
site.py file:

</para><para depth="0">I will try your easy_install (prefix option) suggestion soon ....
</para><para depth="0">"""Append module search paths for third-party packages to sys.path.

</para><para depth="0">****************************************************************
* This module is automatically imported during initialization. *
****************************************************************

</para><para depth="0">In earlier versions of Python (up to 1.5a3), scripts or modules that
needed to use site-specific modules would place ``import site''
somewhere near the top of their code.  Because of the automatic
import, this is no longer necessary (but code that does it still
works).

</para><para depth="0">This will append site-specific paths to the module search path.  On
Unix (including Mac OSX), it starts with sys.prefix and
sys.exec_prefix (if different) and appends
lib/python&lt;version&gt;/site-packages as well as lib/site-python.
On other platforms (such as Windows), it tries each of the
prefixes directly, as well as with lib/site-packages appended.  The
resulting directories, if they exist, are appended to sys.path, and
also inspected for path configuration files.

</para><para depth="0">For Debian and derivatives, this sys.path is augmented with directories
for packages distributed within the distribution. Local addons go
into /usr/local/lib/python&lt;version&gt;/dist-packages, Debian addons
install into /usr/{lib,share}/python&lt;version&gt;/dist-packages.
/usr/lib/python&lt;version&gt;/site-packages is not used.

</para><para depth="0">A path configuration file is a file whose name has the form
&lt;package&gt;.pth; its contents are additional directories (one per line)
to be added to sys.path.  Non-existing directories (or
non-directories) are never added to sys.path; no directory is added to
sys.path more than once.  Blank lines and lines beginning with
'#' are skipped. Lines starting with 'import' are executed.

</para><para depth="0">For example, suppose sys.prefix and sys.exec_prefix are set to
/usr/local and there is a directory /usr/local/lib/python2.5/site-packages
with three subdirectories, foo, bar and spam, and two path
configuration files, foo.pth and bar.pth.  Assume foo.pth contains the
following:

</para><para depth="0">  # foo package configuration
  foo
  bar
  bletch

</para><para depth="0">and bar.pth contains:

</para><para depth="0">  # bar package configuration
  bar

</para><para depth="0">Then the following directories are added to sys.path, in this order:

</para><para depth="0">  /usr/local/lib/python2.5/site-packages/bar
  /usr/local/lib/python2.5/site-packages/foo

</para><para depth="0">Note that bletch is omitted because it doesn't exist; bar precedes foo
because bar.pth comes alphabetically before foo.pth; and spam is
omitted because it is not mentioned in either path configuration file.

</para><para depth="0">After these path manipulations, an attempt is made to import a module
named sitecustomize, which can perform arbitrary additional
site-specific customizations.  If this import fails with an
ImportError exception, it is silently ignored.

</para><para depth="0">"""

</para><para depth="0">import sys
import os
import __builtin__

</para><para depth="0"># Prefixes for site-packages; add additional prefixes like /usr/local here
PREFIXES = [sys.prefix, sys.exec_prefix]
# Enable per user site-packages directory
# set it to False to disable the feature or True to force the feature
ENABLE_USER_SITE = None
# for distutils.commands.install
USER_SITE = None
USER_BASE = None

</para><para depth="0">def makepath(*paths):
    dir = os.path.abspath(os.path.join(*paths))
    return dir, os.path.normcase(dir)

</para><para depth="0">def abs__file__():
    """Set all module' __file__ attribute to an absolute path"""
    for m in sys.modules.values():
        if hasattr(m, '__loader__'):
            continue   # don't mess with a PEP 302-supplied __file__
        try:
            m.__file__ = os.path.abspath(m.__file__)
        except AttributeError:
            continue

</para><para depth="0">def removeduppaths():
    """ Remove duplicate entries from sys.path along with making them
    absolute"""
    # This ensures that the initial path provided by the interpreter contains
    # only absolute pathnames, even if we're running from the build directory.
    L = []
    known_paths = set()
    for dir in sys.path:
        # Filter out duplicate paths (on case-insensitive file systems also
        # if they only differ in case); turn relative paths into absolute
        # paths.
        dir, dircase = makepath(dir)
        if not dircase in known_paths:
            L.append(dir)
            known_paths.add(dircase)
    sys.path[:] = L
    return known_paths

</para><para depth="0">def _init_pathinfo():
    """Return a set containing all existing directory entries from sys.path"""
    d = set()
    for dir in sys.path:
        try:
            if os.path.isdir(dir):
                dir, dircase = makepath(dir)
                d.add(dircase)
        except TypeError:
            continue
    return d

</para><para depth="0">def addpackage(sitedir, name, known_paths):
    """Process a .pth file within the site-packages directory:
       For each line in the file, either combine it with sitedir to a path
       and add that to known_paths, or execute it if it starts with 'import '.
    """
    if known_paths is None:
        _init_pathinfo()
        reset = 1
    else:
        reset = 0
    fullname = os.path.join(sitedir, name)
    try:
        f = open(fullname, "rU")
    except IOError:
        return
    with f:
        for line in f:
            if line.startswith("#"):
                continue
            if line.startswith(("import ", "import\t")):
                exec line
                continue
            line = line.rstrip()
            dir, dircase = makepath(sitedir, line)
            if not dircase in known_paths and os.path.exists(dir):
                sys.path.append(dir)
                known_paths.add(dircase)
    if reset:
        known_paths = None
    return known_paths

</para><para depth="0">def addsitedir(sitedir, known_paths=None):
    """Add 'sitedir' argument to sys.path if missing and handle .pth files in
    'sitedir'"""
    if known_paths is None:
        known_paths = _init_pathinfo()
        reset = 1
    else:
        reset = 0
    sitedir, sitedircase = makepath(sitedir)
    if not sitedircase in known_paths:
        sys.path.append(sitedir)        # Add path component
    try:
        names = os.listdir(sitedir)
    except os.error:
        return
    dotpth = os.extsep + "pth"
    names = [name for name in names if name.endswith(dotpth)]
    for name in sorted(names):
        addpackage(sitedir, name, known_paths)
    if reset:
        known_paths = None
    return known_paths

</para><para depth="0">def check_enableusersite():
    """Check if user site directory is safe for inclusion

</para><para depth="0">    The function tests for the command line flag (including environment var),
    process uid/gid equal to effective uid/gid.

</para><para depth="0">    None: Disabled for security reasons
    False: Disabled by user (command line option)
    True: Safe and enabled
    """
    if sys.flags.no_user_site:
        return False

</para><para depth="0">    if hasattr(os, "getuid") and hasattr(os, "geteuid"):
        # check process uid == effective uid
        if os.geteuid() != os.getuid():
            return None
    if hasattr(os, "getgid") and hasattr(os, "getegid"):
        # check process gid == effective gid
        if os.getegid() != os.getgid():
            return None

</para><para depth="0">    return True

</para><para depth="0">def addusersitepackages(known_paths):
    """Add a per user site-package to sys.path

</para><para depth="0">    Each user has its own python directory with site-packages in the
    home directory.

</para><para depth="0">    USER_BASE is the root directory for all Python versions

</para><para depth="0">    USER_SITE is the user specific site-packages directory

</para><para depth="0">    USER_SITE/.. can be used for data.
    """
    global USER_BASE, USER_SITE, ENABLE_USER_SITE
    env_base = os.environ.get("PYTHONUSERBASE", None)

</para><para depth="0">    def joinuser(*args):
        return os.path.expanduser(os.path.join(*args))

</para><para depth="0">    #if sys.platform in ('os2emx', 'riscos'):
    #    # Don't know what to put here
    #    USER_BASE = ''
    #    USER_SITE = ''
    if os.name == "nt":
        base = os.environ.get("APPDATA") or "~"
        USER_BASE = env_base if env_base else joinuser(base, "Python")
        USER_SITE = os.path.join(USER_BASE,
                                 "Python" + sys.version[0] + sys.version[2],
                                 "site-packages")
    else:
        USER_BASE = env_base if env_base else joinuser("~", ".local")
        USER_SITE = os.path.join(USER_BASE, "lib",
                                 "python" + sys.version[:3],
                                 "site-packages")

</para><para depth="0">    if ENABLE_USER_SITE and os.path.isdir(USER_SITE):
        addsitedir(USER_SITE, known_paths)
    if ENABLE_USER_SITE:
        for dist_libdir in ("lib", "local/lib"):
            user_site = os.path.join(USER_BASE, dist_libdir,
                                     "python" + sys.version[:3],
                                     "dist-packages")
            if os.path.isdir(user_site):
                addsitedir(user_site, known_paths)
    return known_paths

</para><para depth="0">def addsitepackages(known_paths):
    """Add site-packages (and possibly site-python) to sys.path"""
    sitedirs = []
    seen = []

</para><para depth="0">    for prefix in PREFIXES:
        if not prefix or prefix in seen:
            continue
        seen.append(prefix)

</para><para depth="0">        if sys.platform in ('os2emx', 'riscos'):
            sitedirs.append(os.path.join(prefix, "Lib", "site-packages"))
        elif os.sep == '/':
            sitedirs.append(os.path.join(prefix, "lib",
                                        "python" + sys.version[:3],
                                        "dist-packages"))
            sitedirs.append(os.path.join(prefix, "local/lib",
                                        "python" + sys.version[:3],
                                        "dist-packages"))
            sitedirs.append(os.path.join(prefix, "lib", "dist-python"))
        else:
            sitedirs.append(prefix)
            sitedirs.append(os.path.join(prefix, "lib", "site-packages"))

</para><para depth="0">        if sys.platform == "darwin":
            # for framework builds *only* we add the standard Apple
            # locations. Currently only per-user, but /Library and
            # /Network/Library could be added too
            if 'Python.framework' in prefix:
                sitedirs.append(
                    os.path.expanduser(
                        os.path.join("~", "Library", "Python",
                                     sys.version[:3], "site-packages")))

</para><para depth="0">    for sitedir in sitedirs:
        if os.path.isdir(sitedir):
            addsitedir(sitedir, known_paths)

</para><para depth="0">    return known_paths

</para><para depth="0">def setBEGINLIBPATH():
    """The OS/2 EMX port has optional extension modules that do double duty
    as DLLs (and must use the .DLL file extension) for other extensions.
    The library search path needs to be amended so these will be found
    during module import.  Use BEGINLIBPATH so that these are at the start
    of the library search path.

</para><para depth="0">    """
    dllpath = os.path.join(sys.prefix, "Lib", "lib-dynload")
    libpath = os.environ['BEGINLIBPATH'].split(';')
    if libpath[-1]:
        libpath.append(dllpath)
    else:
        libpath[-1] = dllpath
    os.environ['BEGINLIBPATH'] = ';'.join(libpath)

</para><para depth="0">def setquit():
    """Define new built-ins 'quit' and 'exit'.
    These are simply strings that display a hint on how to exit.

</para><para depth="0">    """
    if os.sep == ':':
        eof = 'Cmd-Q'
    elif os.sep == '\\':
        eof = 'Ctrl-Z plus Return'
    else:
        eof = 'Ctrl-D (i.e. EOF)'

</para><para depth="0">    class Quitter(object):
        def __init__(self, name):
            self.name = name
        def __repr__(self):
            return 'Use %s() or %s to exit' % (self.name, eof)
        def __call__(self, code=None):
            # Shells like IDLE catch the SystemExit, but listen when their
            # stdin wrapper is closed.
            try:
                sys.stdin.close()
            except:
                pass
            raise SystemExit(code)
    __builtin__.quit = Quitter('quit')
    __builtin__.exit = Quitter('exit')

</para><para depth="0">class _Printer(object):
    """interactive prompt objects for printing the license text, a list of
    contributors and the copyright notice."""

</para><para depth="0">    MAXLINES = 23

</para><para depth="0">    def __init__(self, name, data, files=(), dirs=()):
        self.__name = name
        self.__data = data
        self.__files = files
        self.__dirs = dirs
        self.__lines = None

</para><para depth="0">    def __setup(self):
        if self.__lines:
            return
        data = None
        for dir in self.__dirs:
            for filename in self.__files:
                filename = os.path.join(dir, filename)
                try:
                    fp = file(filename, "rU")
                    data = fp.read()
                    fp.close()
                    break
                except IOError:
                    pass
            if data:
                break
        if not data:
            data = self.__data
        self.__lines = data.split('\n')
        self.__linecnt = len(self.__lines)

</para><para depth="0">    def __repr__(self):
        self.__setup()
        if len(self.__lines) &lt;= self.MAXLINES:
            return "\n".join(self.__lines)
        else:
            return "Type %s() to see the full %s text" % ((self.__name,)*2)

</para><para depth="0">    def __call__(self):
        self.__setup()
        prompt = 'Hit Return for more, or q (and Return) to quit: '
        lineno = 0
        while 1:
            try:
                for i in range(lineno, lineno + self.MAXLINES):
                    print self.__lines[i]
            except IndexError:
                break
            else:
                lineno += self.MAXLINES
                key = None
                while key is None:
                    key = raw_input(prompt)
                    if key not in ('', 'q'):
                        key = None
                if key == 'q':
                    break

</para><para depth="0">def setcopyright():
    """Set 'copyright' and 'credits' in __builtin__"""
    __builtin__.copyright = _Printer("copyright", sys.copyright)
    if sys.platform[:4] == 'java':
        __builtin__.credits = _Printer(
            "credits",
            "Jython is maintained by the Jython developers (www.jython.org).")
    else:
        __builtin__.credits = _Printer("credits", """\
    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more<br/>information.""")
    here = os.path.dirname(os.__file__)
    __builtin__.license = _Printer(
        "license", "See <url>http://www.python.org/%.3s/license.html</url>" % sys.version,
        ["LICENSE.txt", "LICENSE"],
        [os.path.join(here, os.pardir), here, os.curdir])

</para><para depth="0">class _Helper(object):
    """Define the built-in 'help'.
    This is a wrapper around pydoc.help (with a twist).

</para><para depth="0">    """

</para><para depth="0">    def __repr__(self):
        return "Type help() for interactive help, " \
               "or help(object) for help about object."
    def __call__(self, *args, **kwds):
        import pydoc
        return pydoc.help(*args, **kwds)

</para><para depth="0">def sethelper():
    __builtin__.help = _Helper()

</para><para depth="0">def aliasmbcs():
    """On Windows, some default encodings are not provided by Python,
    while they are always available as "mbcs" in each locale. Make
    them usable by aliasing to "mbcs" in such a case."""
    if sys.platform == 'win32':
        import locale, codecs
        enc = locale.getdefaultlocale()[1]
        if enc.startswith('cp'):            # "cp***" ?
            try:
                codecs.lookup(enc)
            except LookupError:
                import encodings
                encodings._cache[enc] = encodings._unknown
                encodings.aliases.aliases[enc] = 'mbcs'

</para><para depth="0">def setencoding():
    """Set the string encoding used by the Unicode implementation.  The
    default is 'ascii', but if you're willing to experiment, you can
    change this."""
    encoding = "ascii" # Default value set by _PyUnicode_Init()
    if 0:
        # Enable to support locale aware default string encodings.
        import locale
        loc = locale.getdefaultlocale()
        if loc[1]:
            encoding = loc[1]
    if 0:
        # Enable to switch off string to Unicode coercion and implicit
        # Unicode to string conversion.
        encoding = "undefined"
    if encoding != "ascii":
        # On Non-Unicode builds this will raise an AttributeError...
        sys.setdefaultencoding(encoding) # Needs Python Unicode build !

</para><para depth="0">def execsitecustomize():
    """Run custom site specific code, if available."""
    try:
        import sitecustomize
    except ImportError:
        pass

</para><para depth="0">def execusercustomize():
    """Run custom user specific code, if available."""
    try:
        import usercustomize
    except ImportError:
        pass

</para><para depth="0">def main():
    global ENABLE_USER_SITE

</para><para depth="0">    abs__file__()
    known_paths = removeduppaths()
    if ENABLE_USER_SITE is None:
        ENABLE_USER_SITE = check_enableusersite()
    known_paths = addusersitepackages(known_paths)
    known_paths = addsitepackages(known_paths)
    if sys.platform == 'os2emx':
        setBEGINLIBPATH()
    setquit()
    setcopyright()
    sethelper()
    aliasmbcs()
    setencoding()
    execsitecustomize()
    if ENABLE_USER_SITE:
        execusercustomize()
    # Remove sys.setdefaultencoding() so that users cannot change the
    # encoding after initialization.  The test for presence is needed when
    # this module is run as a script, because this code is executed twice.
    if hasattr(sys, "setdefaultencoding"):
        del sys.setdefaultencoding

</para><para depth="0">main()

</para><para depth="0">def _script():
    help = """\
    %s [--user-base] [--user-site]

</para><para depth="0">    Without arguments print some useful information
    With arguments print the value of USER_BASE and/or USER_SITE separated
    by '%s'.

</para><para depth="0">    Exit codes with --user-base or --user-site:
      0 - user site directory is enabled
      1 - user site directory is disabled by user
      2 - uses site directory is disabled by super user
          or for security reasons
     &gt;2 - unknown error
    """
    args = sys.argv[1:]
    if not args:
        print "sys.path = ["
        for dir in sys.path:
            print "    %r," % (dir,)
        print "]"
        print "USER_BASE: %r (%s)" % (USER_BASE,
            "exists" if os.path.isdir(USER_BASE) else "doesn't exist")
        print "USER_SITE: %r (%s)" % (USER_SITE,
            "exists" if os.path.isdir(USER_SITE) else "doesn't exist")
        print "ENABLE_USER_SITE: %r" %  ENABLE_USER_SITE
        sys.exit(0)

</para><para depth="0">    buffer = []
    if '--user-base' in args:
        buffer.append(USER_BASE)
    if '--user-site' in args:
        buffer.append(USER_SITE)

</para><para depth="0">    if buffer:
        print os.pathsep.join(buffer)
        if ENABLE_USER_SITE:
            sys.exit(0)
        elif ENABLE_USER_SITE is False:
            sys.exit(1)
        elif ENABLE_USER_SITE is None:
            sys.exit(2)
        else:
            sys.exit(3)
    else:
        import textwrap
        print textwrap.dedent(help % (sys.argv[0], os.pathsep))
        sys.exit(10)

</para><para depth="0">if __name__ == '__main__':
    _script()
</para><footer type="list-management" depth="0">_______________________________________________
Enthought-Dev mailing list
<email>Enthought-Dev@enthought.com</email>
<url>https://mail.enthought.com/mailman/listinfo/enthought-dev</url>
</footer></body></message>