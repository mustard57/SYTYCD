<message message-id="20110414101657.5993b701@lxorguk.ukuu.org.uk" list="org.kernel.vger.linux-usb" id="24aec7bvb3smkplj" type="development" date="2011-04-14T01:15:52.447642-08:00" year="2011-01-01" year-month="2011-04-01" year-month-day="2011-04-14" thread-id="emxvltog3yy3sw7e"><headers><envelope-from-line>Thu Apr 14 01:16:15 2011</envelope-from-line><from personal="Alan Cox" address="alan@lxorguk.ukuu.org.uk">Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</from><to personal="Elly Jones" address="ellyjones@google.com">Elly Jones &lt;ellyjones@google.com&gt;</to><cc personal="linux-usb@vger.kernel.org" address="linux-usb@vger.kernel.org">linux-usb@vger.kernel.org</cc><subject normal="[PATCH] Add Qualcomm Gobi 2000/3000 driver.">Re: [PATCH] Add Qualcomm Gobi 2000/3000 driver.</subject><received>from srv-117d-be06.markmail.marklogic.com ([172.19.8.66])
          by mail-1.a.markmail.int (JAMES SMTP Server 2.3.1) with SMTP ID 860
          for &lt;archive.user.71132@a.markmail.org&gt;;
          Thu, 14 Apr 2011 01:16:15 -0800 (GMT-08:00)</received><received>from vger.kernel.org (slb-117n.markmail.marklogic.com [172.19.8.33])
	by mgw-2.public.markmail.int (Postfix) with ESMTP id 1601C3B3020D
	for &lt;archive.user.71132@a.markmail.org&gt;; Thu, 14 Apr 2011 02:15:52 -0700 (PDT)</received><received>(majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932542Ab1DNJQO (ORCPT
	&lt;rfc822;archive.user.71132@a.markmail.org&gt;);
	Thu, 14 Apr 2011 05:16:14 -0400</received><received>from earthlight.etchedpixels.co.uk ([81.2.110.250]:42329 "EHLO
	www.etchedpixels.co.uk" rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org
	with ESMTP id S932536Ab1DNJQN (ORCPT
	&lt;rfc822;linux-usb@vger.kernel.org&gt;); Thu, 14 Apr 2011 05:16:13 -0400</received><received>from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by www.etchedpixels.co.uk (8.14.4/8.14.4) with ESMTP id p3E9Gw4w001191;
	Thu, 14 Apr 2011 10:16:58 +0100</received><date>Thu, 14 Apr 2011 10:16:57 +0100</date><message-id>20110414101657.5993b701@lxorguk.ukuu.org.uk</message-id><in-reply-to>&lt;20110413185114.GB1652@google.com&gt;</in-reply-to><references>&lt;20110413185114.GB1652@google.com&gt;</references><x-mailer>Claws Mail 3.7.8 (GTK+ 2.22.0; x86_64-redhat-linux-gnu)</x-mailer><face>iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAFVBMVEWysKsSBQMIAwIZCwj///8wIhxoRDXH9QHCAAABeUlEQVQ4jaXTvW7DIBAAYCQTzz2hdq+rdg494ZmBeE5KYHZjm/d/hJ6NfzBJpp5kRb5PHJwvMPMk2L9As5Y9AmYRBL+HAyJKeOU5aHRhsAAvORQ+UEgAvgddj/lwAXndw2laEDqA4x6KEBhjYRCg9tBFCOuJFxg2OKegbWjbsRTk8PPhKPD7HcRxB7cqhgBRp9Dcqs+B8v4CQvFdqeot3Kov6hBUn0AJitrzY+sgUuiA8i0r7+B3AfqKcN6t8M6HtqQ+AOoELCikgQSbgabKaJW3kn5lBs47JSGDhhLKDUh1UMipwwinMYPTBuIBjEclSaGZUk9hDlTb5sUTYN2SFFQuPe4Gox1X0FZOufjgBiV1Vls7b+GvK3SU4wfmcGo9rPPQzgIabfj4TYQo15k3bTHX9RIw/kniir5YbtJF4jkFG+dsDK1IgE413zAthU/vR2HVMmFUPIHTvF6jWCpFaGw/A3qWgnbxpSm9MSmY5b3pM1gvNc/gQfwBsGwF0VCtxZgAAAAASUVORK5CYII=</face><mime-version>1.0</mime-version><content-type>text/plain; charset=US-ASCII</content-type><content-transfer-encoding>7bit</content-transfer-encoding><sender>linux-usb-owner@vger.kernel.org</sender><precedence>bulk</precedence><list-id>&lt;linux-usb.vger.kernel.org&gt;</list-id><x-mailing-list>linux-usb@vger.kernel.org</x-mailing-list></headers><normalized-references><normalized-message-id>20110414101657.5993b701@lxorguk.ukuu.org.uk</normalized-message-id><normalized-in-reply-to>20110413185114.GB1652@google.com</normalized-in-reply-to><normalized-reference>20110413185114.GB1652@google.com</normalized-reference></normalized-references><body type="text/plain; charset=us-ascii"><para depth="0">Comments inline for the most part - there doesn't seem to be a clear
explained locking model, there are lots of tests in random places with no
apparent locking to make the tests meaningful and there are some other
obvious prblems (missing NULL checks etc).

</para><quote depth="1"><quotepara depth="1">+the device speaks a more complex set of protocols embodied in the closed-source
+Gobi SDK which are necessary to use advanced features of the device.
+Furthermore, firmware (also proprietary) is needed to make the device useful.<br/>An
+open-source firmware loader exists:<br/><url>http://www.codon.org.uk/~mjg59/gobi_loader/</url>.
</quotepara></quote><para depth="0">
So what bits of it actually work without the non-free code ? and what
bits of the driver are only relevant to the non-free code. Ie what bits
should be submitted ?

</para><para depth="0">On the the whole looks like a good basis but the locking really needs to
be much more clearly defined for all these validity/dying type checks.

</para><quote depth="1"><quotepara depth="1">+	dev = kmalloc(sizeof(struct qcusbnet), GFP_KERNEL);
+	if (!dev) {
+		DBG("failed to allocate device buffers\n");
+		return -ENOMEM;
</quotepara></quote><para depth="0">
Seems to leak dev if this works and the next if case fails ?
(Also why not just put them all in one struct given they have the same
object lifetime ?)

</para><quote depth="1"><quotepara depth="1">+	status = qc_register(dev);
+	if (status) {
+		qc_deregister(dev);
</quotepara></quote><para depth="0">
If this falls through is fiddling with addr and dev-&gt; stuff safe ?

</para><quote depth="1"><quotepara depth="1">+	} else {
+		mutex_lock(&amp;qcusbnet_lock);
+		/* Give our initial ref to the list */
+		list_add(&amp;dev-&gt;node, &amp;qcusbnet_list);
+		mutex_unlock(&amp;qcusbnet_lock);
+	}
+	/* After calling qc_register, MEID is valid */
+	addr = &amp;usbnet-&gt;net-&gt;dev_addr[0];
+	for (i = 0; i &lt; 6; i++)
+		addr[i] = (nibble(dev-&gt;meid[i*2+2]) &lt;&lt; 4)+
+			nibble(dev-&gt;meid[i*2+3]);
+	addr[0] &amp;= 0xfe;		/* clear multicast bit */
+	addr[0] |= 0x02;		/* set local assignment bit (IEEE802) */
+
</quotepara></quote><para depth="0">
</para><quote depth="1"><quotepara depth="1">+	for (pos = 4;  pos + 3 &lt; msgsize; pos += msize + 3) {
+		msize = *(u16 *)(msg + pos + 1);
</quotepara></quote><para depth="0">
Is this always guaranteed to be aligned ?

</para><quote depth="1"><quotepara depth="1">+	if (tlv_get(msg, size, 2, &amp;tlv[0], 4) == 4) {
+		if (*(u16 *)&amp;tlv[0] != 0)
</quotepara></quote><para depth="0">
Ditto the others of this form

</para><quote depth="1"><quotepara depth="1">+#define true      1
+#define false     0
+
+#define ENOMEM    12
+#define EFAULT    14
+#define EINVAL    22
+#define ENOMSG    42
+#define ENODATA   61
</quotepara></quote><para depth="0">
WTF ?????

</para><quote depth="1"><quotepara depth="1">+#define IOCTL_QMI_GET_SERVICE_FILE      (0x8BE0 + 1)
+#define IOCTL_QMI_GET_DEVICE_VIDPID     (0x8BE0 + 2)
+#define IOCTL_QMI_GET_DEVICE_MEID       (0x8BE0 + 3)
+#define IOCTL_QMI_CLOSE                 (0x8BE0 + 4)
+#define CDC_GET_ENCAPSULATED_RESPONSE	0x01A1ll
+#define CDC_CONNECTION_SPEED_CHANGE	0x08000000002AA1ll
</quotepara></quote><para depth="0">
We have IOR/IOW/etc macros for building ioctl numbers and it should be
using those. To start with that helps enormously for trace tools as it
shows the directions and sizes in the ioctl code

</para><quote depth="1"><quotepara depth="1">+		if (client-&gt;cid == cid || (client-&gt;cid | 0xff00) == cid) {
+			copy = kmalloc(size, GFP_ATOMIC);
+			memcpy(copy, data, size);
</quotepara></quote><para depth="0">
copy == NULL, memcpy over NULL whoops bang splat

</para><quote depth="1"><quotepara depth="1">+	if (!device_valid(dev)) {
+		DBG("Invalid device!\n");
+		return -ENXIO;
+	}
</quotepara></quote><para depth="0">
So what locking here ensures dev stays valid ?

</para><quote depth="1"><quotepara depth="1">+		result = down_interruptible(&amp;sem);
</quotepara></quote><para depth="0">
Really wants to be a mutex so it'll work with the realtime stuff

</para><quote depth="1"><quotepara depth="1">+	if (handle-&gt;dev-&gt;dying) {
+		DBG("Dying device");
+		return -ENXIO;
+	}
+
+	if (!device_valid(handle-&gt;dev)) {
+		DBG("Invalid device!\n");
+		return -ENXIO;
+	}
</quotepara></quote><para depth="0">
So like validity - what lock stops it dying mid ioctl 

</para><quote depth="1"><quotepara depth="1">+	struct qmihandle *handle = (struct qmihandle *)file-&gt;private_data;
</quotepara></quote><para depth="0">
Lots of casts that are not needed

</para><quote depth="1"><quotepara depth="1">+static ssize_t devqmi_write(struct file *file, const char __user * buf,
+			    size_t size, loff_t *pos)
+{
+	int status;
+	void *wbuf;
+	struct qmihandle *handle = (struct qmihandle *)file-&gt;private_data;
+
+	if (!handle) {
+		DBG("Bad file data\n");
+		return -EBADF;
+	}
</quotepara></quote><para depth="0">
Exactly how can this check occur - why is it present, and if it is
relevant what locks prevent whatever it checks from occuring during the
execution ?

</para><quote depth="1"><quotepara depth="1">+
+	if (!device_valid(handle-&gt;dev)) {
+		DBG("Invalid device! Updating f_ops\n");
+		file-&gt;f_op = file-&gt;f_dentry-&gt;d_inode-&gt;i_fop;
+		return -ENXIO;
+	}
+
+	if (handle-&gt;cid == (u16)-1) {
+		DBG("Client ID must be set before writing 0x%04X\n",
+			  handle-&gt;cid);
+		return -EBADR;
+	}
+
+	wbuf = kmalloc(size + qmux_size, GFP_KERNEL);
</quotepara></quote><para depth="0">
Maths overflow ?

</para><footer type="list-management" depth="0">--
To unsubscribe from this list: send the line "unsubscribe linux-usb" in
the body of a message to <email>majordomo@vger.kernel.org</email>
More majordomo info at  <url>http://vger.kernel.org/majordomo-info.html</url>
</footer></body></message>