<message message-id="3f0b79eb1002081757j28e8c132qfba1b8a869848f00@mail.gmail.com" list="org.postgresql.pgsql-hackers" id="24cle3lpngcbuaj7" type="development" date="2010-02-09T10:57:44+09:00" year="2010-01-01" year-month="2010-02-01" year-month-day="2010-02-08" thread-id="mznbxiaxmssxribz"><headers><envelope-from-line>Mon Feb 08 17:59:27 2010</envelope-from-line><from personal="Fujii Masao" address="masao.fujii@gmail.com">Fujii Masao &lt;masao.fujii@gmail.com&gt;</from><to personal="Heikki Linnakangas" address="heikki.linnakangas@enterprisedb.com">Heikki Linnakangas &lt;heikki.linnakangas@enterprisedb.com&gt;</to><cc personal="Thom Brown" address="thombrown@gmail.com">Thom Brown &lt;thombrown@gmail.com&gt;</cc><subject normal="[HACKERS] Streaming replication in docs">Re: [HACKERS] Streaming replication in docs</subject><received>from srv-117c-be06.markmail.marklogic.com ([172.19.8.46])
          by mail-1.a.markmail.int (JAMES SMTP Server 2.3.1) with SMTP ID 539
          for &lt;juan.avila.conrad@a.markmail.org&gt;;
          Mon, 8 Feb 2010 17:59:27 -0800 (GMT-08:00)</received><received>from mx2.hub.org (slb-117n.markmail.marklogic.com [172.19.8.33])
	by mgw-1.public.markmail.int (Postfix) with ESMTP id 47218290855A
	for &lt;juan.avila.conrad@a.markmail.org&gt;; Mon,  8 Feb 2010 17:58:36 -0800 (PST)</received><received>from postgresql.org (mail.postgresql.org [200.46.204.86])
	by mx2.hub.org (Postfix) with ESMTP id 548341E8130A;
	Mon,  8 Feb 2010 21:58:57 -0400 (AST)</received><received>from maia.hub.org (unknown [200.46.208.211])
	by mail.postgresql.org (Postfix) with ESMTP id 75C07632FCD
	for &lt;pgsql-hackers-postgresql.org@mail.postgresql.org&gt;; Mon,  8 Feb 2010 21:58:05 -0400 (AST)</received><received>from mail.postgresql.org ([200.46.204.86])
 by maia.hub.org (mx1.hub.org [200.46.208.211]) (amavisd-maia, port 10024)
 with ESMTP id 23656-09
 for &lt;pgsql-hackers-postgresql.org@mail.postgresql.org&gt;;
 Tue,  9 Feb 2010 01:57:12 +0000 (UTC)</received><x-greylist>domain auto-whitelisted by SQLgrey-1.7.6</x-greylist><received>from mail-yx0-f202.google.com (mail-yx0-f202.google.com [209.85.210.202])
	by mail.postgresql.org (Postfix) with ESMTP id 38857632AEC
	for &lt;pgsql-hackers@postgresql.org&gt;; Mon,  8 Feb 2010 21:57:46 -0400 (AST)</received><received>by yxe40 with SMTP id 40so2985241yxe.19
        for &lt;pgsql-hackers@postgresql.org&gt;; Mon, 08 Feb 2010 17:57:44 -0800 (PST)</received><dkim-signature>v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:mime-version:received:in-reply-to:references
         :date:message-id:subject:from:to:cc:content-type;
        bh=JtXay29WEFC2QnNHAL9lM6Ri95+K+k663XkCXhogpws=;
        b=RKP+u/8ob/DN+ywrRxeNLn0fqa3yKGy1yw0uNZuC+rMUdoPkikJ1ShC4FrIt7647k1
         o114buAji3aJMhxMFLCSSSS/+24DV+coCqFDhmcgRatOEjcvzTGe3VLG1Mk7H/LCuEZN
         kOQm/5pE7bBkSLXphOy+8ZWpZQqj1I4RBCIrY=</dkim-signature><domainkey-signature>a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=mime-version:in-reply-to:references:date:message-id:subject:from:to
         :cc:content-type;
        b=jTdNFpZjzu/aUDq/NTBlW/e1LesdcU+k/bcZF61vBOxLR06H8LCGzlzD82FM/k68bz
         jAleGjeVmC19iRNs/lMSmt4D/cdOaz58iME4qjigQI3lu0m560KNMYtKhwnaWL8trqfG
         fvRTOINtxNlSwsSCOnLslE1CeSq6DNHyuQfwg=</domainkey-signature><mime-version>1.0</mime-version><received>by 10.100.62.19 with SMTP id k19mr5532151ana.230.1265680664453; Mon, 
	08 Feb 2010 17:57:44 -0800 (PST)</received><in-reply-to>&lt;4B6E9A9E.5020202@enterprisedb.com&gt;</in-reply-to><references>&lt;bddc86151002070220p25facb02p1f25b60755971788@mail.gmail.com&gt;
	 &lt;bddc86151002070241xf3e9771i397382bd0293144@mail.gmail.com&gt;
	 &lt;4B6E9A9E.5020202@enterprisedb.com&gt;</references><date>Tue, 9 Feb 2010 10:57:44 +0900</date><message-id>3f0b79eb1002081757j28e8c132qfba1b8a869848f00@mail.gmail.com</message-id><content-type>multipart/mixed; boundary=00163623a9e16765ad047f213ef1</content-type><x-virus-scanned>Maia Mailguard 1.0.1</x-virus-scanned><x-spam-status>No, hits=0.217 tagged_above=-10 required=5 tests=AWL=-1.545,
 BAYES_50=0.001, FS_REPLICA=1.041, SARE_SPEC_REPLICA=0.72</x-spam-status><x-spam-level/><x-mailing-list>pgsql-hackers</x-mailing-list><list-archive>&lt;http://archives.postgresql.org/pgsql-hackers&gt;</list-archive><list-help>&lt;mailto:majordomo@postgresql.org?body=help&gt;</list-help><list-id>&lt;pgsql-hackers.postgresql.org&gt;</list-id><list-owner>&lt;mailto:pgsql-hackers-owner@postgresql.org&gt;</list-owner><list-post>&lt;mailto:pgsql-hackers@postgresql.org&gt;</list-post><list-subscribe>&lt;mailto:majordomo@postgresql.org?body=sub%20pgsql-hackers&gt;</list-subscribe><list-unsubscribe>&lt;mailto:majordomo@postgresql.org?body=unsub%20pgsql-hackers&gt;</list-unsubscribe><precedence>bulk</precedence><sender>pgsql-hackers-owner@postgresql.org</sender></headers><attachments><attachment type="text/x-patch" file="replication-doc-layout-change.patch" size="166718" uri="/24cle3lpngcbuaj7/attach00/replication-doc-layout-change.patch" extension="patch"><page page="1"><attachpara>*** a/doc/src/sgml/backup.sgml
--- b/doc/src/sgml/backup.sgml
***************
*** 1492,2879 **** archive_command = 'local_backup_script.sh'
    &lt;/sect2&gt;
   &lt;/sect1&gt;
  
-  &lt;sect1 id="warm-standby"&gt;
-   &lt;title&gt;Warm Standby Servers for High Availability&lt;/title&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;warm standby&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;PITR standby&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;standby server&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;log shipping&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;witness server&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;STONITH&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;high availability&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;para&gt;
-    Continuous archiving can be used to create a &lt;firstterm&gt;high
-    availability&lt;/&gt; (HA) cluster configuration with one or more
-    &lt;firstterm&gt;standby servers&lt;/&gt; ready to take over operations if the
-    primary server fails. This capability is widely referred to as
-    &lt;firstterm&gt;warm standby&lt;/&gt; or &lt;firstterm&gt;log shipping&lt;/&gt;.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    The primary and standby server work together to provide this capability,
-    though the servers are only loosely coupled. The primary server operates
-    in continuous archiving mode, while each standby server operates in
-    continuous recovery mode, reading the WAL files from the primary. No
-    changes to the database tables are required to enable this capability,
-    so it offers low administration overhead compared to some other
-    replication approaches. This configuration also has relatively low
-    performance impact on the primary server.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    Directly moving WAL records from one database server to another
-    is typically described as log shipping. &lt;productname&gt;PostgreSQL&lt;/&gt;
-    implements file-based log shipping, which means that WAL records are
-    transferred one file (WAL segment) at a time. WAL files (16MB) can be
-    shipped easily and cheaply over any distance, whether it be to an
-    adjacent system, another system at the same site, or another system on
-    the far side of the globe. The bandwidth required for this technique
-    varies according to the transaction rate of the primary server.
-    Record-based log shipping is also possible with custom-developed
-    procedures, as discussed in &lt;xref linkend="warm-standby-record"&gt;.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    It should be noted that the log shipping is asynchronous, i.e., the WAL
-    records are shipped after transaction commit. As a result there is a
-    window for data loss should the primary server suffer a catastrophic
-    failure: transactions not yet shipped will be lost.  The length of the
-    window of data loss can be limited by use of the
-    &lt;varname&gt;archive_timeout&lt;/varname&gt; parameter, which can be set as low
-    as a few seconds if required.  However such a low setting will
-    substantially increase the bandwidth required for file shipping.
-    If you need a window of less than a minute or so, it's probably better
-    to consider record-based log shipping.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    The standby server is not available for access, since it is continually
-    performing recovery processing. Recovery performance is sufficiently
-    good that the standby will typically be only moments away from full
-    availability once it has been activated. As a result, we refer to this
-    capability as a warm standby configuration that offers high
-    availability. Restoring a server from an archived base backup and
-    rollforward will take considerably longer, so that technique only
-    offers a solution for disaster recovery, not high availability.
-   &lt;/para&gt;
- 
-   &lt;sect2 id="warm-standby-planning"&gt;
-    &lt;title&gt;Planning&lt;/title&gt;
- 
-    &lt;para&gt;
-     It is usually wise to create the primary and standby servers
-     so that they are as similar as possible, at least from the
-     perspective of the database server.  In particular, the path names
-     associated with tablespaces will be passed across unmodified, so both
-     primary and standby servers must have the same mount paths for
-     tablespaces if that feature is used.  Keep in mind that if
-     &lt;xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"&gt;
-     is executed on the primary, any new mount point needed for it must
-     be created on the primary and all standby servers before the command
-     is executed. Hardware need not be exactly the same, but experience shows
-     that maintaining two identical systems is easier than maintaining two
-     dissimilar ones over the lifetime of the application and system.
-     In any case the hardware architecture must be the same &amp;mdash; shipping
-     from, say, a 32-bit to a 64-bit system will not work.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In general, log shipping between servers running different major
-     &lt;productname&gt;PostgreSQL&lt;/&gt; release
-     levels is not possible. It is the policy of the PostgreSQL Global
-     Development Group not to make changes to disk formats during minor release
-     upgrades, so it is likely that running different minor release levels
-     on primary and standby servers will work successfully. However, no
-     formal support for that is offered and you are advised to keep primary
-     and standby servers at the same release level as much as possible.
-     When updating to a new minor release, the safest policy is to update
-     the standby servers first &amp;mdash; a new minor release is more likely
-     to be able to read WAL files from a previous minor release than vice
-     versa.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     There is no special mode required to enable a standby server. The
-     operations that occur on both primary and standby servers are
-     normal continuous archiving and recovery tasks. The only point of
-     contact between the two database servers is the archive of WAL files
-     that both share: primary writing to the archive, standby reading from
-     the archive. Care must be taken to ensure that WAL archives from separate
-     primary servers do not become mixed together or confused. The archive
-     need not be large if it is only required for standby operation.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The magic that makes the two loosely coupled servers work together is
-     simply a &lt;varname&gt;restore_command&lt;/&gt; used on the standby that,
-     when asked for the next WAL file, waits for it to become available from
-     the primary. The &lt;varname&gt;restore_command&lt;/&gt; is specified in the
-     &lt;filename&gt;recovery.conf&lt;/&gt; file on the standby server. Normal recovery
-     processing would request a file from the WAL archive, reporting failure
-     if the file was unavailable.  For standby processing it is normal for
-     the next WAL file to be unavailable, so we must be patient and wait for
-     it to appear. For files ending in &lt;literal&gt;.backup&lt;/&gt; or
-     &lt;literal&gt;.history&lt;/&gt; there is no need to wait, and a non-zero return
-     code must be returned. A waiting &lt;varname&gt;restore_command&lt;/&gt; can be
-     written as a custom script that loops after polling for the existence of
-     the next WAL file. There must also be some way to trigger failover, which
-     should interrupt the &lt;varname&gt;restore_command&lt;/&gt;, break the loop and
-     return a file-not-found error to the standby server. This ends recovery
-     and the standby will then come up as a normal server.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Pseudocode for a suitable &lt;varname&gt;restore_command&lt;/&gt; is:
- &lt;programlisting&gt;
- triggered = false;
- while (!NextWALFileReady() &amp;amp;&amp;amp; !triggered)
- {
-     sleep(100000L);         /* wait for ~0.1 sec */
-     if (CheckForExternalTrigger())
-         triggered = true;
- }
- if (!triggered)
-         CopyWALFileForRecovery();
- &lt;/programlisting&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     A working example of a waiting &lt;varname&gt;restore_command&lt;/&gt; is provided
-     as a &lt;filename&gt;contrib&lt;/&gt; module named &lt;application&gt;pg_standby&lt;/&gt;. It
-     should be used as a reference on how to correctly implement the logic
-     described above. It can also be extended as needed to support specific
-     configurations and environments.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;PostgreSQL&lt;/productname&gt; does not provide the system
-     software required to identify a failure on the primary and notify
-     the standby database server.  Many such tools exist and are well
-     integrated with the operating system facilities required for
-     successful failover, such as IP address migration.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The method for triggering failover is an important part of planning
-     and design. One potential option is the &lt;varname&gt;restore_command&lt;/&gt;
-     command.  It is executed once for each WAL file, but the process
-     running the &lt;varname&gt;restore_command&lt;/&gt; is created and dies for
-     each file, so there is no daemon or server process, and we cannot
-     use signals or a signal handler. Therefore, the
-     &lt;varname&gt;restore_command&lt;/&gt; is not suitable to trigger failover.
-     It is possible to use a simple timeout facility, especially if
-     used in conjunction with a known &lt;varname&gt;archive_timeout&lt;/&gt;
-     setting on the primary. However, this is somewhat error prone
-     since a network problem or busy primary server might be sufficient
-     to initiate failover. A notification mechanism such as the explicit
-     creation of a trigger file is ideal, if this can be arranged.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The size of the WAL archive can be minimized by using the &lt;literal&gt;%r&lt;/&gt;
-     option of the &lt;varname&gt;restore_command&lt;/&gt;. This option specifies the
-     last archive file name that needs to be kept to allow the recovery to
-     restart correctly. This can be used to truncate the archive once
-     files are no longer required, assuming the archive is writable from the
-     standby server.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="warm-standby-config"&gt;
-    &lt;title&gt;Implementation&lt;/title&gt;
- 
-    &lt;para&gt;
-     The short procedure for configuring a standby server is as follows. For
-     full details of each step, refer to previous sections as noted.
-     &lt;orderedlist&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up primary and standby systems as nearly identical as
-        possible, including two identical copies of
-        &lt;productname&gt;PostgreSQL&lt;/&gt; at the same release level.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up continuous archiving from the primary to a WAL archive
-        directory on the standby server. Ensure that
-        &lt;xref linkend="guc-archive-mode"&gt;,
-        &lt;xref linkend="guc-archive-command"&gt; and
-        &lt;xref linkend="guc-archive-timeout"&gt;
-        are set appropriately on the primary
-        (see &lt;xref linkend="backup-archiving-wal"&gt;).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Make a base backup of the primary server (see &lt;xref
-        linkend="backup-base-backup"&gt;), and load this data onto the standby.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Begin recovery on the standby server from the local WAL
-        archive, using a &lt;filename&gt;recovery.conf&lt;/&gt; that specifies a
-        &lt;varname&gt;restore_command&lt;/&gt; that waits as described
-        previously (see &lt;xref linkend="backup-pitr-recovery"&gt;).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-     &lt;/orderedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Recovery treats the WAL archive as read-only, so once a WAL file has
-     been copied to the standby system it can be copied to tape at the same
-     time as it is being read by the standby database server.
-     Thus, running a standby server for high availability can be performed at
-     the same time as files are stored for longer term disaster recovery
-     purposes.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     For testing purposes, it is possible to run both primary and standby
-     servers on the same system. This does not provide any worthwhile
-     improvement in server robustness, nor would it be described as HA.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="warm-standby-failover"&gt;
-    &lt;title&gt;Failover&lt;/title&gt;
- 
-    &lt;para&gt;
-     If the primary server fails then the standby server should begin
-     failover procedures.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If the standby server fails then no failover need take place. If the
-     standby server can be restarted, even some time later, then the recovery
-     process can also be immediately restarted, taking advantage of
-     restartable recovery. If the standby server cannot be restarted, then a
-     full new standby server instance should be created.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If the primary server fails and the standby server becomes the
-     new primary, and then the old primary restarts, you must have
-     a mechanism for informing old primary that it is no longer the primary. This is
-     sometimes known as STONITH (Shoot The Other Node In The Head), which is
-     necessary to avoid situations where both systems think they are the
-     primary, which will lead to confusion and ultimately data loss.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Many failover systems use just two systems, the primary and the standby,
-     connected by some kind of heartbeat mechanism to continually verify the
-     connectivity between the two and the viability of the primary. It is
-     also possible to use a third system (called a witness server) to prevent
-     some cases of inappropriate failover, but the additional complexity
-     might not be worthwhile unless it is set up with sufficient care and
-     rigorous testing.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Once failover to the standby occurs, we have only a
-     single server in operation. This is known as a degenerate state.
-     The former standby is now the primary, but the former primary is down
-     and might stay down.  To return to normal operation we must
-     fully recreate a standby server,
-     either on the former primary system when it comes up, or on a third,
-     possibly new, system. Once complete the primary and standby can be
-     considered to have switched roles. Some people choose to use a third
-     server to provide backup for the new primary until the new standby
-     server is recreated,
-     though clearly this complicates the system configuration and
-     operational processes.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     So, switching from primary to standby server can be fast but requires
-     some time to re-prepare the failover cluster. Regular switching from
-     primary to standby is useful, since it allows regular downtime on
-     each system for maintenance. This also serves as a test of the
-     failover mechanism to ensure that it will really work when you need it.
-     Written administration procedures are advised.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="warm-standby-record"&gt;
-    &lt;title&gt;Record-based Log Shipping&lt;/title&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;PostgreSQL&lt;/productname&gt; directly supports file-based
-     log shipping as described above. It is also possible to implement
-     record-based log shipping, though this requires custom development.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     An external program can call the &lt;function&gt;pg_xlogfile_name_offset()&lt;/&gt;
-     function (see &lt;xref linkend="functions-admin"&gt;)
-     to find out the file name and the exact byte offset within it of
-     the current end of WAL.  It can then access the WAL file directly
-     and copy the data from the last known end of WAL through the current end
-     over to the standby servers.  With this approach, the window for data
-     loss is the polling cycle time of the copying program, which can be very
-     small, and there is no wasted bandwidth from forcing partially-used
-     segment files to be archived.  Note that the standby servers'
-     &lt;varname&gt;restore_command&lt;/&gt; scripts can only deal with whole WAL files,
-     so the incrementally copied data is not ordinarily made available to
-     the standby servers.  It is of use only when the primary dies &amp;mdash;
-     then the last partial WAL file is fed to the standby before allowing
-     it to come up.  The correct implementation of this process requires
-     cooperation of the &lt;varname&gt;restore_command&lt;/&gt; script with the data
-     copying program.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Starting with &lt;productname&gt;PostgreSQL&lt;/&gt; version 8.5, you can use
-     streaming replication (see &lt;xref linkend="streaming-replication"&gt;) to
-     achieve the same with less effort.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="streaming-replication"&gt;
-    &lt;title&gt;Streaming Replication&lt;/title&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;PostgreSQL&lt;/&gt; includes a simple streaming replication
-     mechanism, which lets the standby server to stay more up-to-date than
-     file-based replication allows. The standby connects to the primary
-     and the primary starts streaming WAL records from where the standby
-     left off, and continues streaming them as they are generated, without
-     waiting for the WAL file to be filled. So with streaming replication,
-     &lt;varname&gt;archive_timeout&lt;/&gt; does not need to be configured.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Streaming replication relies on file-based continuous archiving for
-     making the base backup and for allowing a standby to catch up if it's
-     disconnected from the primary for long enough for the primary to
-     delete old WAL files still required by the standby.
-    &lt;/para&gt;
- 
-    &lt;sect3 id="streaming-replication-setup"&gt;
-     &lt;title&gt;Setup&lt;/title&gt;
-     &lt;para&gt;
-      The short procedure for configuring streaming replication is as follows.
-      For full details of each step, refer to other sections as noted.
-      &lt;orderedlist&gt;
-       &lt;listitem&gt;
-        &lt;para&gt;
-         Set up primary and standby systems as near identically as possible,
-         including two identical copies of &lt;productname&gt;PostgreSQL&lt;/&gt; at the
-         same release level.
-        &lt;/para&gt;
-       &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up continuous archiving from the primary to a WAL archive located
-        in a directory on the standby server. Ensure that
-        &lt;xref linkend="guc-archive-mode"&gt;,
-        &lt;xref linkend="guc-archive-command"&gt; and
-        &lt;xref linkend="guc-archive-timeout"&gt;
-        are set appropriately on the primary
-        (see &lt;xref linkend="backup-archiving-wal"&gt;).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
- 
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up connections and authentication so that the standby server can
-        successfully connect to the pseudo &lt;literal&gt;replication&lt;/&gt; database of
-        the primary server (see
-        &lt;xref linkend="streaming-replication-authentication"&gt;). Ensure that
-        &lt;xref linkend="guc-listen-addresses"&gt; and &lt;filename&gt;pg_hba.conf&lt;/&gt; are
-        configured appropriately on the primary.
-       &lt;/para&gt;
-       &lt;para&gt;
-        On systems that support the keepalive socket option, setting
-        &lt;xref linkend="guc-tcp-keepalives-idle"&gt;,
-        &lt;xref linkend="guc-tcp-keepalives-interval"&gt; and
-        &lt;xref linkend="guc-tcp-keepalives-count"&gt; helps you to find the
-        troubles with replication (e.g., the network outage or the failure of
-        the standby server) as soon as possible.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set the maximum number of concurrent connections from the standby servers
-        (see &lt;xref linkend="guc-max-wal-senders"&gt; for details).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Enable WAL archiving in the primary server because we need to make a base
-        backup of it later (see &lt;xref linkend="guc-archive-mode"&gt; and
-        &lt;xref linkend="guc-archive-command"&gt; for details).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the primary.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Make a base backup of the primary server (see
-        &lt;xref linkend="backup-base-backup"&gt;), and load this data onto the
-        standby. Note that all files present in &lt;filename&gt;pg_xlog&lt;/&gt;
-        and &lt;filename&gt;pg_xlog/archive_status&lt;/&gt; on the &lt;emphasis&gt;standby&lt;/&gt;
-        server should be removed because they might be obsolete.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up WAL archiving, connections and authentication like the primary
-        server, because the standby server might work as a primary server after
-        failover. Ensure that your settings are consistent with the
-        &lt;emphasis&gt;future&lt;/&gt; environment after the primary and the standby
-        server are interchanged by failover. If you're setting up the standby
-        server for e.g reporting purposes, with no plans to fail over to it,
-        configure the standby accordingly.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Create a recovery command file &lt;filename&gt;recovery.conf&lt;/&gt; in the data
-        directory on the standby server.
-       &lt;/para&gt;
- 
-       &lt;variablelist id="replication-config-settings" xreflabel="Replication Settings"&gt;
-        &lt;varlistentry id="standby-mode" xreflabel="standby_mode"&gt;
-         &lt;term&gt;&lt;varname&gt;standby_mode&lt;/varname&gt; (&lt;type&gt;boolean&lt;/type&gt;)&lt;/term&gt;
-         &lt;listitem&gt;
-          &lt;para&gt;
-           Specifies whether to start the &lt;productname&gt;PostgreSQL&lt;/&gt; server as
-           a standby. If this parameter is &lt;literal&gt;on&lt;/&gt;, the streaming
-           replication is enabled and the standby server will try to connect
-           to the primary to receive and apply WAL records continuously. The
-           default is &lt;literal&gt;off&lt;/&gt;, which allows only an archive recovery
-           without replication. So, streaming replication requires this
-           parameter to be explicitly set to &lt;literal&gt;on&lt;/&gt;.
-          &lt;/para&gt;
-         &lt;/listitem&gt;
-        &lt;/varlistentry&gt;
-        &lt;varlistentry id="primary-conninfo" xreflabel="primary_conninfo"&gt;
-         &lt;term&gt;&lt;varname&gt;primary_conninfo&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
-         &lt;listitem&gt;
-          &lt;para&gt;
-           Specifies a connection string which is used for the standby server
-           to connect with the primary. This string is in the same format as
-           described in &lt;xref linkend="libpq-connect"&gt;. If any option is
-           unspecified in this string, then the corresponding environment
-           variable (see &lt;xref linkend="libpq-envars"&gt;) is checked. If the
-           environment variable is not set either, then the indicated built-in
-           defaults are used.
-          &lt;/para&gt;
-          &lt;para&gt;
-           The built-in replication requires that a host name (or host address)
-           or port number which the primary server listens on should be
-           specified in this string, respectively. Also ensure that a role with
-           the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt; privileges on the
-           primary is set (see
-           &lt;xref linkend="streaming-replication-authentication"&gt;). Note that
-           the password needs to be set if the primary demands password
-           authentication.
-          &lt;/para&gt;
-         &lt;/listitem&gt;
-        &lt;/varlistentry&gt;
-        &lt;varlistentry id="trigger-file" xreflabel="trigger_file"&gt;
-         &lt;term&gt;&lt;varname&gt;trigger_file&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
-         &lt;listitem&gt;
-          &lt;para&gt;
-           Specifies a trigger file whose presence activates the standby.
-           If no trigger file is specified, the standby never exits
-           recovery.
-          &lt;/para&gt;
-         &lt;/listitem&gt;
-        &lt;/varlistentry&gt;
-       &lt;/variablelist&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the standby. The standby
-        server will go into recovery mode and proceeds to receive WAL records
-        from the primary and apply them continuously.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;/orderedlist&gt;
-     &lt;/para&gt;
-    &lt;/sect3&gt;
-    &lt;sect3 id="streaming-replication-authentication"&gt;
-     &lt;title&gt;Authentication&lt;/title&gt;
-     &lt;para&gt;
-      It's very important that the access privilege for replication are set
-      properly so that only trusted users can read the WAL stream, because it's
-      easy to extract serious information from it.
-     &lt;/para&gt;
-     &lt;para&gt;
-      Only superuser is allowed to connect to the primary as the replication
-      standby. So a role with the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt;
-      privileges needs to be created in the primary.
-     &lt;/para&gt;
-     &lt;para&gt;
-      Client authentication for replication is controlled by the
-      &lt;filename&gt;pg_hba.conf&lt;/&gt; record specifying &lt;literal&gt;replication&lt;/&gt; in the
-      &lt;replaceable&gt;database&lt;/&gt; field. For example, if the standby is running on
-      host IP &lt;literal&gt;192.168.1.100&lt;/&gt; and the superuser's name for replication
-      is &lt;literal&gt;foo&lt;/&gt;, the administrator can add the following line to the
-      &lt;filename&gt;pg_hba.conf&lt;/&gt; file on the primary.
- 
- &lt;programlisting&gt;
- # Allow the user "foo" from host 192.168.1.100 to connect to the primary
- # as a replication standby if the user's password is correctly supplied.
- #
- # TYPE  DATABASE        USER            CIDR-ADDRESS            METHOD
- host    replication     foo             192.168.1.100/32        md5
- &lt;/programlisting&gt;
-     &lt;/para&gt;
-     &lt;para&gt;
-      The host name and port number of the primary, user name to connect as,
-      and password are specified in the &lt;filename&gt;recovery.conf&lt;/&gt; file or
-      the corresponding environment variable on the standby.
-      For example, if the primary is running on host IP &lt;literal&gt;192.168.1.50&lt;/&gt;,
-      port &lt;literal&gt;5432&lt;/literal&gt;, the superuser's name for replication is
-      &lt;literal&gt;foo&lt;/&gt;, and the password is &lt;literal&gt;foopass&lt;/&gt;, the administrator
-      can add the following line to the &lt;filename&gt;recovery.conf&lt;/&gt; file on the
-      standby.
- 
- &lt;programlisting&gt;
- # The standby connects to the primary that is running on host 192.168.1.50
- # and port 5432 as the user "foo" whose password is "foopass".
- primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
- &lt;/programlisting&gt;
-     &lt;/para&gt;
-    &lt;/sect3&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="backup-incremental-updated"&gt;
-    &lt;title&gt;Incrementally Updated Backups&lt;/title&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;incrementally updated backups&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;change accumulation&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-    &lt;para&gt;
-     In a warm standby configuration, it is possible to offload the expense of
-     taking periodic base backups from the primary server; instead base backups
-     can be made by backing
-     up a standby server's files.  This concept is generally known as
-     incrementally updated backups, log change accumulation, or more simply,
-     change accumulation.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If we take a file system backup of the standby server's data
-     directory while it is processing
-     logs shipped from the primary, we will be able to reload that backup and
-     restart the standby's recovery process from the last restart point.
-     We no longer need to keep WAL files from before the standby's restart point.
-     If we need to recover, it will be faster to recover from the incrementally
-     updated backup than from the original base backup.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Since the standby server is not &lt;quote&gt;live&lt;/&gt;, it is not possible to
-     use &lt;function&gt;pg_start_backup()&lt;/&gt; and &lt;function&gt;pg_stop_backup()&lt;/&gt;
-     to manage the backup process; it will be up to you to determine how
-     far back you need to keep WAL segment files to have a recoverable
-     backup.  You can do this by running &lt;application&gt;pg_controldata&lt;/&gt;
-     on the standby server to inspect the control file and determine the
-     current checkpoint WAL location, or by using the
-     &lt;varname&gt;log_checkpoints&lt;/&gt; option to print values to the standby's
-     server log.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
-  &lt;/sect1&gt;
- 
-  &lt;sect1 id="hot-standby"&gt;
-   &lt;title&gt;Hot Standby&lt;/title&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;Hot Standby&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-    &lt;para&gt;
-     Hot Standby is the term used to describe the ability to connect to
-     the server and run queries while the server is in archive recovery. This
-     is useful for both log shipping replication and for restoring a backup
-     to an exact state with great precision.
-     The term Hot Standby also refers to the ability of the server to move
-     from recovery through to normal running while users continue running
-     queries and/or continue their connections.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Running queries in recovery is in many ways the same as normal running
-     though there are a large number of usage and administrative points
-     to note.
-    &lt;/para&gt;
- 
-   &lt;sect2 id="hot-standby-users"&gt;
-    &lt;title&gt;User's Overview&lt;/title&gt;
- 
-    &lt;para&gt;
-     Users can connect to the database while the server is in recovery
-     and perform read-only queries. Read-only access to catalogs and views
-     will also occur as normal.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The data on the standby takes some time to arrive from the primary server
-     so there will be a measurable delay between primary and standby. Running the
-     same query nearly simultaneously on both primary and standby might therefore
-     return differing results. We say that data on the standby is eventually
-     consistent with the primary.
-     Queries executed on the standby will be correct with regard to the transactions
-     that had been recovered at the start of the query, or start of first statement,
-     in the case of serializable transactions. In comparison with the primary,
-     the standby returns query results that could have been obtained on the primary
-     at some exact moment in the past.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     When a transaction is started in recovery, the parameter
-     &lt;varname&gt;transaction_read_only&lt;/&gt; will be forced to be true, regardless of the
-     &lt;varname&gt;default_transaction_read_only&lt;/&gt; setting in &lt;filename&gt;postgresql.conf&lt;/&gt;.
-     It can't be manually set to false either. As a result, all transactions
-     started during recovery will be limited to read-only actions only. In all
-     other ways, connected sessions will appear identical to sessions
-     initiated during normal processing mode. There are no special commands
-     required to initiate a connection at this time, so all interfaces
-     work normally without change. After recovery finishes, the session
-     will allow normal read-write transactions at the start of the next
-     transaction, if these are requested.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Read-only here means "no writes to the permanent database tables".
-     There are no problems with queries that make use of transient sort and
-     work files.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The following actions are allowed
- 
-     &lt;itemizedlist&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Query access - SELECT, COPY TO including views and SELECT RULEs
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Cursor commands - DECLARE, FETCH, CLOSE,
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Parameters - SHOW, SET, RESET
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Transaction management commands
-         &lt;itemizedlist&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            BEGIN, END, ABORT, START TRANSACTION
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            SAVEPOINT, RELEASE, ROLLBACK TO SAVEPOINT
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            EXCEPTION blocks and other internal subtransactions
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-         &lt;/itemizedlist&gt;
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        LOCK TABLE, though only when explicitly in one of these modes:
-        ACCESS SHARE, ROW SHARE or ROW EXCLUSIVE.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Plans and resources - PREPARE, EXECUTE, DEALLOCATE, DISCARD
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Plugins and extensions - LOAD
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-     &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     These actions produce error messages
- 
-     &lt;itemizedlist&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Data Manipulation Language (DML) - INSERT, UPDATE, DELETE, COPY FROM, TRUNCATE.
-        Note that there are no allowed actions that result in a trigger
-        being executed during recovery.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Data Definition Language (DDL) - CREATE, DROP, ALTER, COMMENT.
-        This also applies to temporary tables currently because currently their
-        definition causes writes to catalog tables.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        SELECT ... FOR SHARE | UPDATE which cause row locks to be written
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        RULEs on SELECT statements that generate DML commands.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        LOCK TABLE, in short default form, since it requests ACCESS EXCLUSIVE MODE.
-        LOCK TABLE that explicitly requests a mode higher than ROW EXCLUSIVE MODE.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Transaction management commands that explicitly set non-read only state
-         &lt;itemizedlist&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-             BEGIN READ WRITE,
-             START TRANSACTION READ WRITE
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-             SET TRANSACTION READ WRITE,
-             SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            SET transaction_read_only = off
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-         &lt;/itemizedlist&gt;
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Two-phase commit commands - PREPARE TRANSACTION, COMMIT PREPARED,
-        ROLLBACK PREPARED because even read-only transactions need to write
-        WAL in the prepare phase (the first phase of two phase commit).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        sequence update - nextval()
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        LISTEN, UNLISTEN, NOTIFY since they currently write to system tables
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-     &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Note that current behaviour of read only transactions when not in
-     recovery is to allow the last two actions, so there are small and
-     subtle differences in behaviour between read-only transactions
-     run on standby and during normal running.
-     It is possible that the restrictions on LISTEN, UNLISTEN, NOTIFY and
-     temporary tables may be lifted in a future release, if their internal
-     implementation is altered to make this possible.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If failover or switchover occurs the database will switch to normal
-     processing mode. Sessions will remain connected while the server
-     changes mode. Current transactions will continue, though will remain
-     read-only. After recovery is complete, it will be possible to initiate
-     read-write transactions.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Users will be able to tell whether their session is read-only by
-     issuing SHOW transaction_read_only.  In addition a set of
-     functions &lt;xref linkend="functions-recovery-info-table"&gt; allow users to
-     access information about Hot Standby. These allow you to write
-     functions that are aware of the current state of the database. These
-     can be used to monitor the progress of recovery, or to allow you to
-     write complex programs that restore the database to particular states.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In recovery, transactions will not be permitted to take any table lock
-     higher than RowExclusiveLock. In addition, transactions may never assign
-     a TransactionId and may never write WAL.
-     Any &lt;command&gt;LOCK TABLE&lt;/&gt; command that runs on the standby and requests
-     a specific lock mode higher than ROW EXCLUSIVE MODE will be rejected.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In general queries will not experience lock conflicts with the database
-     changes made by recovery. This is becase recovery follows normal
-     concurrency control mechanisms, known as &lt;acronym&gt;MVCC&lt;/&gt;. There are
-     some types of change that will cause conflicts, covered in the following
-     section.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-conflict"&gt;
-    &lt;title&gt;Handling query conflicts&lt;/title&gt;
- 
-    &lt;para&gt;
-     The primary and standby nodes are in many ways loosely connected. Actions
-     on the primary will have an effect on the standby. As a result, there is
-     potential for negative interactions or conflicts between them. The easiest
-     conflict to understand is performance: if a huge data load is taking place
-     on the primary then this will generate a similar stream of WAL records on the
-     standby, so standby queries may contend for system resources, such as I/O.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     There are also additional types of conflict that can occur with Hot Standby.
-     These conflicts are &lt;emphasis&gt;hard conflicts&lt;/&gt; in the sense that we may
-     need to cancel queries and in some cases disconnect sessions to resolve them.
-     The user is provided with a number of optional ways to handle these
-     conflicts, though we must first understand the possible reasons behind a conflict.
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Access Exclusive Locks from primary node, including both explicit
-          LOCK commands and various kinds of DDL action
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Dropping tablespaces on the primary while standby queries are using
-          those tablespaces for temporary work files (work_mem overflow)
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Dropping databases on the primary while users are connected to that
-          database on the standby.
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Waiting to acquire buffer cleanup locks
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Early cleanup of data still visible to the current query's snapshot
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Some WAL redo actions will be for DDL actions. These DDL actions are
-     repeating actions that have already committed on the primary node, so
-     they must not fail on the standby node. These DDL locks take priority
-     and will automatically *cancel* any read-only transactions that get in
-     their way, after a grace period. This is similar to the possibility of
-     being canceled by the deadlock detector, but in this case the standby
-     process always wins, since the replayed actions must not fail. This
-     also ensures that replication doesn't fall behind while we wait for a
-     query to complete. Again, we assume that the standby is there for high
-     availability purposes primarily.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     An example of the above would be an Administrator on Primary server
-     runs a &lt;command&gt;DROP TABLE&lt;/&gt; on a table that's currently being queried
-     in the standby server.
-     Clearly the query cannot continue if we let the &lt;command&gt;DROP TABLE&lt;/&gt;
-     proceed. If this situation occurred on the primary, the &lt;command&gt;DROP TABLE&lt;/&gt;
-     would wait until the query has finished. When the query is on the standby
-     and the &lt;command&gt;DROP TABLE&lt;/&gt; is on the primary, the primary doesn't have
-     information about which queries are running on the standby and so the query
-     does not wait on the primary. The WAL change records come through to the
-     standby while the standby query is still running, causing a conflict.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The most common reason for conflict between standby queries and WAL redo is
-     "early cleanup". Normally, &lt;productname&gt;PostgreSQL&lt;/&gt; allows cleanup of old
-     row versions when there are no users who may need to see them to ensure correct
-     visibility of data (the heart of MVCC). If there is a standby query that has
-     been running for longer than any query on the primary then it is possible
-     for old row versions to be removed by either a vacuum or HOT. This will
-     then generate WAL records that, if applied, would remove data on the
-     standby that might *potentially* be required by the standby query.
-     In more technical language, the primary's xmin horizon is later than
-     the standby's xmin horizon, allowing dead rows to be removed.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Experienced users should note that both row version cleanup and row version
-     freezing will potentially conflict with recovery queries. Running a
-     manual &lt;command&gt;VACUUM FREEZE&lt;/&gt; is likely to cause conflicts even on tables
-     with no updated or deleted rows.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     We have a number of choices for resolving query conflicts.  The default
-     is that we wait and hope the query completes. The server will wait
-     automatically until the lag between primary and standby is at most
-     &lt;varname&gt;max_standby_delay&lt;/&gt; seconds. Once that grace period expires,
-     we take one of the following actions:
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          If the conflict is caused by a lock, we cancel the conflicting standby
-          transaction immediately. If the transaction is idle-in-transaction
-          then currently we abort the session instead, though this may change
-          in the future.
-         &lt;/para&gt;
-        &lt;/listitem&gt;
- 
-        &lt;listitem&gt;
-         &lt;para&gt;
-          If the conflict is caused by cleanup records we tell the standby query
-          that a conflict has occurred and that it must cancel itself to avoid the
-          risk that it silently fails to read relevant data because
-          that data has been removed. (This is regrettably very similar to the
-          much feared and iconic error message "snapshot too old"). Some cleanup
-          records only cause conflict with older queries, though some types of
-          cleanup record affect all queries.
-         &lt;/para&gt;
- 
-         &lt;para&gt;
-          If cancellation does occur, the query and/or transaction can always
-          be re-executed. The error is dynamic and will not necessarily occur
-          the same way if the query is executed again.
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;varname&gt;max_standby_delay&lt;/&gt; is set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
-     The parameter applies to the server as a whole so if the delay is all used
-     up by a single query then there may be little or no waiting for queries that
-     follow immediately, though they will have benefited equally from the initial
-     waiting period. The server may take time to catch up again before the grace
-     period is available again, though if there is a heavy and constant stream
-     of conflicts it may seldom catch up fully.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Users should be clear that tables that are regularly and heavily updated on
-     primary server will quickly cause cancellation of longer running queries on
-     the standby. In those cases &lt;varname&gt;max_standby_delay&lt;/&gt; can be
-     considered somewhat but not exactly the same as setting
-     &lt;varname&gt;statement_timeout&lt;/&gt;.
-     &lt;/para&gt;
- 
-    &lt;para&gt;
-     Other remedial actions exist if the number of cancellations is unacceptable.
-     The first option is to connect to primary server and keep a query active
-     for as long as we need to run queries on the standby. This guarantees that
-     a WAL cleanup record is never generated and we don't ever get query
-     conflicts as described above. This could be done using contrib/dblink
-     and pg_sleep(), or via other mechanisms. If you do this, you should note
-     that this will delay cleanup of dead rows by vacuum or HOT and many
-     people may find this undesirable. However, we should remember that
-     primary and standby nodes are linked via the WAL, so this situation is no
-     different to the case where we ran the query on the primary node itself
-     except we have the benefit of off-loading the execution onto the standby.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     It is also possible to set &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; on the primary
-     to defer the cleanup of records by autovacuum, vacuum and HOT. This may allow
-     more time for queries to execute before they are cancelled on the standby,
-     without the need for setting a high &lt;varname&gt;max_standby_delay&lt;/&gt;.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Three-way deadlocks are possible between AccessExclusiveLocks arriving from
-     the primary, cleanup WAL records that require buffer cleanup locks and
-     user requests that are waiting behind replayed AccessExclusiveLocks. Deadlocks
-     are resolved by time-out when we exceed &lt;varname&gt;max_standby_delay&lt;/&gt;.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Dropping tablespaces or databases is discussed in the administrator's
-     section since they are not typical user situations.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-admin"&gt;
-    &lt;title&gt;Administrator's Overview&lt;/title&gt;
- 
-    &lt;para&gt;
-     If there is a &lt;filename&gt;recovery.conf&lt;/&gt; file present the server will start
-     in Hot Standby mode by default, though &lt;varname&gt;recovery_connections&lt;/&gt; can
-     be disabled via &lt;filename&gt;postgresql.conf&lt;/&gt;, if required. The server may take
-     some time to enable recovery connections since the server must first complete
-     sufficient recovery to provide a consistent state against which queries
-     can run before enabling read only connections. Look for these messages
-     in the server logs
- 
- &lt;programlisting&gt;
- LOG:  initializing recovery connections
- 
- ... then some time later ...
- 
- LOG:  consistent recovery state reached
- LOG:  database system is ready to accept read only connections
- &lt;/programlisting&gt;
- 
-     Consistency information is recorded once per checkpoint on the primary, as long
-     as &lt;varname&gt;recovery_connections&lt;/&gt; is enabled (on the primary). If this parameter
-     is disabled, it will not be possible to enable recovery connections on the standby.
-     The consistent state can also be delayed in the presence of both of these conditions
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          a write transaction has more than 64 subtransactions
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          very long-lived write transactions
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
- 
-     If you are running file-based log shipping ("warm standby"), you may need
-     to wait until the next WAL file arrives, which could be as long as the
-     &lt;varname&gt;archive_timeout&lt;/&gt; setting on the primary.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The setting of some parameters on the standby will need reconfiguration
-     if they have been changed on the primary. The value on the standby must
-     be equal to or greater than the value on the primary. If these parameters
-     are not set high enough then the standby will not be able to track work
-     correctly from recovering transactions. If these values are set too low the
-     the server will halt. Higher values can then be supplied and the server
-     restarted to begin recovery again.
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          &lt;varname&gt;max_connections&lt;/&gt;
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          &lt;varname&gt;max_prepared_transactions&lt;/&gt;
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          &lt;varname&gt;max_locks_per_transaction&lt;/&gt;
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     It is important that the administrator consider the appropriate setting
-     of &lt;varname&gt;max_standby_delay&lt;/&gt;, set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
-     There is no optimal setting and should be set according to business
-     priorities. For example if the server is primarily tasked as a High
-     Availability server, then you may wish to lower
-     &lt;varname&gt;max_standby_delay&lt;/&gt; or even set it to zero, though that is a
-     very aggressive setting. If the standby server is tasked as an additional
-     server for decision support queries then it may be acceptable to set this
-     to a value of many hours (in seconds).
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Transaction status "hint bits" written on primary are not WAL-logged,
-     so data on standby will likely re-write the hints again on the standby.
-     Thus the main database blocks will produce write I/Os even though
-     all users are read-only; no changes have occurred to the data values
-     themselves.  Users will be able to write large sort temp files and
-     re-generate relcache info files, so there is no part of the database
-     that is truly read-only during hot standby mode. There is no restriction
-     on the use of set returning functions, or other users of tuplestore/tuplesort
-     code. Note also that writes to remote databases will still be possible,
-     even though the transaction is read-only locally.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The following types of administrator command are not accepted
-     during recovery mode
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Data Definition Language (DDL) - e.g. CREATE INDEX
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Privilege and Ownership - GRANT, REVOKE, REASSIGN
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Maintenance commands - ANALYZE, VACUUM, CLUSTER, REINDEX
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Note again that some of these commands are actually allowed during
-     "read only" mode transactions on the primary.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     As a result, you cannot create additional indexes that exist solely
-     on the standby, nor can statistics that exist solely on the standby.
-     If these administrator commands are needed they should be executed
-     on the primary so that the changes will propagate through to the
-     standby.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;function&gt;pg_cancel_backend()&lt;/&gt; will work on user backends, but not the
-     Startup process, which performs recovery. pg_stat_activity does not
-     show an entry for the Startup process, nor do recovering transactions
-     show as active. As a result, pg_prepared_xacts is always empty during
-     recovery. If you wish to resolve in-doubt prepared transactions
-     then look at pg_prepared_xacts on the primary and issue commands to
-     resolve those transactions there.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     pg_locks will show locks held by backends as normal. pg_locks also shows
-     a virtual transaction managed by the Startup process that owns all
-     AccessExclusiveLocks held by transactions being replayed by recovery.
-     Note that Startup process does not acquire locks to
-     make database changes and thus locks other than AccessExclusiveLocks
-     do not show in pg_locks for the Startup process, they are just presumed
-     to exist.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;check_pgsql&lt;/&gt; will work, but it is very simple.
-     &lt;productname&gt;check_postgres&lt;/&gt; will also work, though many some actions
-     could give different or confusing results.
-     e.g. last vacuum time will not be maintained for example, since no
-     vacuum occurs on the standby (though vacuums running on the primary do
-     send their changes to the standby).
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     WAL file control commands will not work during recovery
-     e.g. &lt;function&gt;pg_start_backup&lt;/&gt;, &lt;function&gt;pg_switch_xlog&lt;/&gt; etc..
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Dynamically loadable modules work, including pg_stat_statements.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Advisory locks work normally in recovery, including deadlock detection.
-     Note that advisory locks are never WAL logged, so it is not possible for
-     an advisory lock on either the primary or the standby to conflict with WAL
-     replay. Nor is it possible to acquire an advisory lock on the primary
-     and have it initiate a similar advisory lock on the standby. Advisory
-     locks relate only to a single server on which they are acquired.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Trigger-based replication systems such as &lt;productname&gt;Slony&lt;/&gt;,
-     &lt;productname&gt;Londiste&lt;/&gt; and &lt;productname&gt;Bucardo&lt;/&gt; won't run on the
-     standby at all, though they will run happily on the primary server as
-     long as the changes are not sent to standby servers to be applied.
-     WAL replay is not trigger-based so you cannot relay from the
-     standby to any system that requires additional database writes or
-     relies on the use of triggers.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     New oids cannot be assigned, though some &lt;acronym&gt;UUID&lt;/&gt; generators may still
-     work as long as they do not rely on writing new status to the database.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Currently, temp table creation is not allowed during read only
-     transactions, so in some cases existing scripts will not run correctly.
-     It is possible we may relax that restriction in a later release. This is
-     both a SQL Standard compliance issue and a technical issue.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;command&gt;DROP TABLESPACE&lt;/&gt; can only succeed if the tablespace is empty.
-     Some standby users may be actively using the tablespace via their
-     &lt;varname&gt;temp_tablespaces&lt;/&gt; parameter. If there are temp files in the
-     tablespace we currently cancel all active queries to ensure that temp
-     files are removed, so that we can remove the tablespace and continue with
-     WAL replay.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Running &lt;command&gt;DROP DATABASE&lt;/&gt;, &lt;command&gt;ALTER DATABASE ... SET TABLESPACE&lt;/&gt;,
-     or &lt;command&gt;ALTER DATABASE ... RENAME&lt;/&gt; on primary will generate a log message
-     that will cause all users connected to that database on the standby to be
-     forcibly disconnected. This action occurs immediately, whatever the setting of
-     &lt;varname&gt;max_standby_delay&lt;/&gt;.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In normal running, if you issue &lt;command&gt;DROP USER&lt;/&gt; or &lt;command&gt;DROP ROLE&lt;/&gt;
-     for a role with login capability while that user is still connected then
-     nothing happens to the connected user - they remain connected. The user cannot
-     reconnect however. This behaviour applies in recovery also, so a
-     &lt;command&gt;DROP USER&lt;/&gt; on the primary does not disconnect that user on the standby.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Stats collector is active during recovery. All scans, reads, blocks,
-     index usage etc will all be recorded normally on the standby. Replayed
-     actions will not duplicate their effects on primary, so replaying an
-     insert will not increment the Inserts column of pg_stat_user_tables.
-     The stats file is deleted at start of recovery, so stats from primary
-     and standby will differ; this is considered a feature not a bug.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Autovacuum is not active during recovery, though will start normally
-     at the end of recovery.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Background writer is active during recovery and will perform
-     restartpoints (similar to checkpoints on primary) and normal block
-     cleaning activities. The &lt;command&gt;CHECKPOINT&lt;/&gt; command is accepted during recovery,
-     though performs a restartpoint rather than a new checkpoint.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-parameters"&gt;
-    &lt;title&gt;Hot Standby Parameter Reference&lt;/title&gt;
- 
-    &lt;para&gt;
-     Various parameters have been mentioned above in the &lt;xref linkend="hot-standby-admin"&gt;
-     and &lt;xref linkend="hot-standby-conflict"&gt; sections.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     On the primary, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
-     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; can be used to enable and control the
-     primary server to assist the successful configuration of Hot Standby servers.
-     &lt;varname&gt;max_standby_delay&lt;/&gt; has no effect if set on the primary.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     On the standby, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
-     &lt;varname&gt;max_standby_delay&lt;/&gt; can be used to enable and control Hot Standby.
-     standby server to assist the successful configuration of Hot Standby servers.
-     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; has no effect during recovery.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-caveats"&gt;
-    &lt;title&gt;Caveats&lt;/title&gt;
- 
-    &lt;para&gt;
-     At this writing, there are several limitations of Hot Standby.
-     These can and probably will be fixed in future releases:
- 
-   &lt;itemizedlist&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      Operations on hash indexes are not presently WAL-logged, so
-      replay will not update these indexes.  Hash indexes will not be
-      used for query plans during recovery.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      Full knowledge of running transactions is required before snapshots
-      may be taken. Transactions that take use large numbers of subtransactions
-      (currently greater than 64) will delay the start of read only
-      connections until the completion of the longest running write transaction.
-      If this situation occurs explanatory messages will be sent to server log.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      Valid starting points for recovery connections are generated at each
-      checkpoint on the master. If the standby is shutdown while the master
-      is in a shutdown state it may not be possible to re-enter Hot Standby
-      until the primary is started up so that it generates further starting
-      points in the WAL logs. This is not considered a serious issue
-      because the standby is usually switched into the primary role while
-      the first node is taken down.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      At the end of recovery, AccessExclusiveLocks held by prepared transactions
-      will require twice the normal number of lock table entries. If you plan
-      on running either a large number of concurrent prepared transactions
-      that normally take AccessExclusiveLocks, or you plan on having one
-      large transaction that takes many AccessExclusiveLocks then you are
-      advised to select a larger value of &lt;varname&gt;max_locks_per_transaction&lt;/&gt;,
-      up to, but never more than twice the value of the parameter setting on
-      the primary server in rare extremes. You need not consider this at all if
-      your setting of &lt;varname&gt;max_prepared_transactions&lt;/&gt; is &lt;literal&gt;0&lt;/&gt;.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-   &lt;/itemizedlist&gt;
- 
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-  &lt;/sect1&gt;
- 
   &lt;sect1 id="migration"&gt;
    &lt;title&gt;Migration Between Releases&lt;/title&gt;
  
--- 1492,1497 ----
*** a/doc/src/sgml/high-availability.sgml
--- b/doc/src/sgml/high-availability.sgml
***************
*** 79,84 ****
--- 79,87 ----
    also available.
   &lt;/para&gt;
  
+  &lt;sect1 id="different-replication-solutions"&gt;
+  &lt;title&gt;Comparison of different solutions&lt;/title&gt;
+ 
   &lt;variablelist&gt;
  
    &lt;varlistentry&gt;
***************
*** 450,453 **** protocol to make nodes agree on a serializable transactional order.
--- 453,1840 ----
  
   &lt;/variablelist&gt;
  
+  &lt;/sect1&gt;
+ 
+  &lt;sect1 id="warm-standby"&gt;
+   &lt;title&gt;File-based Log Shipping&lt;/title&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;warm standby&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;PITR standby&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;standby server&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;log shipping&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;witness server&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;STONITH&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;para&gt;
+    Continuous archiving can be used to create a &lt;firstterm&gt;high
+    availability&lt;/&gt; (HA) cluster configuration with one or more
+    &lt;firstterm&gt;standby servers&lt;/&gt; ready to take over operations if the
+    primary server fails. This capability is widely referred to as
+    &lt;firstterm&gt;warm standby&lt;/&gt; or &lt;firstterm&gt;log shipping&lt;/&gt;.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    The primary and standby server work together to provide this capability,
+    though the servers are only loosely coupled. The primary server operates
+    in continuous archiving mode, while each standby server operates in
+    continuous recovery mode, reading the WAL files from the primary. No
+    changes to the database tables are required to enable this capability,
+    so it offers low administration overhead compared to some other
+    replication approaches. This configuration also has relatively low
+    performance impact on the primary server.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    Directly moving WAL records from one database server to another
+    is typically described as log shipping. &lt;productname&gt;PostgreSQL&lt;/&gt;
+    implements file-based log shipping, which means that WAL records are
+    transferred one file (WAL segment) at a time. WAL files (16MB) can be
+    shipped easily and cheaply over any distance, whether it be to an
+    adjacent system, another system at the same site, or another system on
+    the far side of the globe. The bandwidth required for this technique
+    varies according to the transaction rate of the primary server.
+    Record-based log shipping is also possible with custom-developed
+    procedures, as discussed in &lt;xref linkend="warm-standby-record"&gt;.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    It should be noted that the log shipping is asynchronous, i.e., the WAL
+    records are shipped after transaction commit. As a result there is a
+    window for data loss should the primary server suffer a catastrophic
+    failure: transactions not yet shipped will be lost.  The length of the
+    window of data loss can be limited by use of the
+    &lt;varname&gt;archive_timeout&lt;/varname&gt; parameter, which can be set as low
+    as a few seconds if required.  However such a low setting will
+    substantially increase the bandwidth required for file shipping.
+    If you need a window of less than a minute or so, it's probably better
+    to consider record-based log shipping.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    The standby server is not available for access, since it is continually
+    performing recovery processing. Recovery performance is sufficiently
+    good that the standby will typically be only moments away from full
+    availability once it has been activated. As a result, we refer to this
+    capability as a warm standby configuration that offers high
+    availability. Restoring a server from an archived base backup and
+    rollforward will take considerably longer, so that technique only
+    offers a solution for disaster recovery, not high availability.
+   &lt;/para&gt;
+ 
+   &lt;sect2 id="warm-standby-planning"&gt;
+    &lt;title&gt;Planning&lt;/title&gt;
+ 
+    &lt;para&gt;
+     It is usually wise to create the primary and standby servers
+     so that they are as similar as possible, at least from the
+     perspective of the database server.  In particular, the path names
+     associated with tablespaces will be passed across unmodified, so both
+     primary and standby servers must have the same mount paths for
+     tablespaces if that feature is used.  Keep in mind that if
+     &lt;xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"&gt;
+     is executed on the primary, any new mount point needed for it must
+     be created on the primary and all standby servers before the command
+     is executed. Hardware need not be exactly the same, but experience shows
+     that maintaining two identical systems is easier than maintaining two
+     dissimilar ones over the lifetime of the application and system.
+     In any case the hardware architecture must be the same &amp;mdash; shipping
+     from, say, a 32-bit to a 64-bit system will not work.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In general, log shipping between servers running different major
+     &lt;productname&gt;PostgreSQL&lt;/&gt; release
+     levels is not possible. It is the policy of the PostgreSQL Global
+     Development Group not to make changes to disk formats during minor release
+     upgrades, so it is likely that running different minor release levels
+     on primary and standby servers will work successfully. However, no
+     formal support for that is offered and you are advised to keep primary
+     and standby servers at the same release level as much as possible.
+     When updating to a new minor release, the safest policy is to update
+     the standby servers first &amp;mdash; a new minor release is more likely
+     to be able to read WAL files from a previous minor release than vice
+     versa.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     There is no special mode required to enable a standby server. The
+     operations that occur on both primary and standby servers are
+     normal continuous archiving and recovery tasks. The only point of
+     contact between the two database servers is the archive of WAL files
+     that both share: primary writing to the archive, standby reading from
+     the archive. Care must be taken to ensure that WAL archives from separate
+     primary servers do not become mixed together or confused. The archive
+     need not be large if it is only required for standby operation.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The magic that makes the two loosely coupled servers work together is
+     simply a &lt;varname&gt;restore_command&lt;/&gt; used on the standby that,
+     when asked for the next WAL file, waits for it to become available from
+     the primary. The &lt;varname&gt;restore_command&lt;/&gt; is specified in the
+     &lt;filename&gt;recovery.conf&lt;/&gt; file on the standby server. Normal recovery
+     processing would request a file from the WAL archive, reporting failure
+     if the file was unavailable.  For standby processing it is normal for
+     the next WAL file to be unavailable, so we must be patient and wait for
+     it to appear. For files ending in &lt;literal&gt;.backup&lt;/&gt; or
+     &lt;literal&gt;.history&lt;/&gt; there is no need to wait, and a non-zero return
+     code must be returned. A waiting &lt;varname&gt;restore_command&lt;/&gt; can be
+     written as a custom script that loops after polling for the existence of
+     the next WAL file. There must also be some way to trigger failover, which
+     should interrupt the &lt;varname&gt;restore_command&lt;/&gt;, break the loop and
+     return a file-not-found error to the standby server. This ends recovery
+     and the standby will then come up as a normal server.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Pseudocode for a suitable &lt;varname&gt;restore_command&lt;/&gt; is:
+ &lt;programlisting&gt;
+ triggered = false;
+ while (!NextWALFileReady() &amp;amp;&amp;amp; !triggered)
+ {
+     sleep(100000L);         /* wait for ~0.1 sec */
+     if (CheckForExternalTrigger())
+         triggered = true;
+ }
+ if (!triggered)
+         CopyWALFileForRecovery();
+ &lt;/programlisting&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     A working example of a waiting &lt;varname&gt;restore_command&lt;/&gt; is provided
+     as a &lt;filename&gt;contrib&lt;/&gt; module named &lt;application&gt;pg_standby&lt;/&gt;. It
+     should be used as a reference on how to correctly implement the logic
+     described above. It can also be extended as needed to support specific
+     configurations and environments.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;PostgreSQL&lt;/productname&gt; does not provide the system
+     software required to identify a failure on the primary and notify
+     the standby database server.  Many such tools exist and are well
+     integrated with the operating system facilities required for
+     successful failover, such as IP address migration.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The method for triggering failover is an important part of planning
+     and design. One potential option is the &lt;varname&gt;restore_command&lt;/&gt;
+     command.  It is executed once for each WAL file, but the process
+     running the &lt;varname&gt;restore_command&lt;/&gt; is created and dies for
+     each file, so there is no daemon or server process, and we cannot
+     use signals or a signal handler. Therefore, the
+     &lt;varname&gt;restore_command&lt;/&gt; is not suitable to trigger failover.
+     It is possible to use a simple timeout facility, especially if
+     used in conjunction with a known &lt;varname&gt;archive_timeout&lt;/&gt;
+     setting on the primary. However, this is somewhat error prone
+     since a network problem or busy primary server might be sufficient
+     to initiate failover. A notification mechanism such as the explicit
+     creation of a trigger file is ideal, if this can be arranged.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The size of the WAL archive can be minimized by using the &lt;literal&gt;%r&lt;/&gt;
+     option of the &lt;varname&gt;restore_command&lt;/&gt;. This option specifies the
+     last archive file name that needs to be kept to allow the recovery to
+     restart correctly. This can be used to truncate the archive once
+     files are no longer required, assuming the archive is writable from the
+     standby server.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="warm-standby-config"&gt;
+    &lt;title&gt;Implementation&lt;/title&gt;
+ 
+    &lt;para&gt;
+     The short procedure for configuring a standby server is as follows. For
+     full details of each step, refer to previous sections as noted.
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up primary and standby systems as nearly identical as
+        possible, including two identical copies of
+        &lt;productname&gt;PostgreSQL&lt;/&gt; at the same release level.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up continuous archiving from the primary to a WAL archive
+        directory on the standby server. Ensure that
+        &lt;xref linkend="guc-archive-mode"&gt;,
+        &lt;xref linkend="guc-archive-command"&gt; and
+        &lt;xref linkend="guc-archive-timeout"&gt;
+        are set appropriately on the primary
+        (see &lt;xref linkend="backup-archiving-wal"&gt;).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Make a base backup of the primary server (see &lt;xref
+        linkend="backup-base-backup"&gt;), and load this data onto the standby.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Begin recovery on the standby server from the local WAL
+        archive, using a &lt;filename&gt;recovery.conf&lt;/&gt; that specifies a
+        &lt;varname&gt;restore_command&lt;/&gt; that waits as described
+        previously (see &lt;xref linkend="backup-pitr-recovery"&gt;).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Recovery treats the WAL archive as read-only, so once a WAL file has
+     been copied to the standby system it can be copied to tape at the same
+     time as it is being read by the standby database server.
+     Thus, running a standby server for high availability can be performed at
+     the same time as files are stored for longer term disaster recovery
+     purposes.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     For testing purposes, it is possible to run both primary and standby
+     servers on the same system. This does not provide any worthwhile
+     improvement in server robustness, nor would it be described as HA.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="warm-standby-record"&gt;
+    &lt;title&gt;Record-based Log Shipping&lt;/title&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;PostgreSQL&lt;/productname&gt; directly supports file-based
+     log shipping as described above. It is also possible to implement
+     record-based log shipping, though this requires custom development.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     An external program can call the &lt;function&gt;pg_xlogfile_name_offset()&lt;/&gt;
+     function (see &lt;xref linkend="functions-admin"&gt;)
+     to find out the file name and the exact byte offset within it of
+     the current end of WAL.  It can then access the WAL file directly
+     and copy the data from the last known end of WAL through the current end
+     over to the standby servers.  With this approach, the window for data
+     loss is the polling cycle time of the copying program, which can be very
+     small, and there is no wasted bandwidth from forcing partially-used
+     segment files to be archived.  Note that the standby servers'
+     &lt;varname&gt;restore_command&lt;/&gt; scripts can only deal with whole WAL files,
+     so the incrementally copied data is not ordinarily made available to
+     the standby servers.  It is of use only when the primary dies &amp;mdash;
+     then the last partial WAL file is fed to the standby before allowing
+     it to come up.  The correct implementation of this process requires
+     cooperation of the &lt;varname&gt;restore_command&lt;/&gt; script with the data
+     copying program.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Starting with &lt;productname&gt;PostgreSQL&lt;/&gt; version 8.5, you can use
+     streaming replication (see &lt;xref linkend="streaming-replication"&gt;) to
+     achieve the same with less effort.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+  &lt;/sect1&gt;
+ 
+   &lt;sect1 id="streaming-replication"&gt;
+    &lt;title&gt;Streaming Replication&lt;/title&gt;
+ 
+    &lt;indexterm zone="high-availability"&gt;
+     &lt;primary&gt;Streaming Replication&lt;/primary&gt;
+    &lt;/indexterm&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;PostgreSQL&lt;/&gt; includes a simple streaming replication
+     mechanism, which lets the standby server to stay more up-to-date than
+     file-based replication allows. The standby connects to the primary
+     and the primary starts streaming WAL records from where the standby
+     left off, and continues streaming them as they are generated, without
+     waiting for the WAL file to be filled. So with streaming replication,
+     &lt;varname&gt;archive_timeout&lt;/&gt; does not need to be configured.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Streaming replication relies on file-based continuous archiving for
+     making the base backup and for allowing a standby to catch up if it's
+     disconnected from the primary for long enough for the primary to
+     delete old WAL files still required by the standby.
+    &lt;/para&gt;
+ 
+    &lt;sect2 id="streaming-replication-setup"&gt;
+     &lt;title&gt;Setup&lt;/title&gt;
+     &lt;para&gt;
+      The short procedure for configuring streaming replication is as follows.
+      For full details of each step, refer to other sections as noted.
+      &lt;orderedlist&gt;
+       &lt;listitem&gt;
+        &lt;para&gt;
+         Set up primary and standby systems as near identically as possible,
+         including two identical copies of &lt;productname&gt;PostgreSQL&lt;/&gt; at the
+         same release level.
+        &lt;/para&gt;
+       &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up continuous archiving from the primary to a WAL archive located
+        in a directory on the standby server. Ensure that
+        &lt;xref linkend="guc-archive-mode"&gt;,
+        &lt;xref linkend="guc-archive-command"&gt; and
+        &lt;xref linkend="guc-archive-timeout"&gt;
+        are set appropriately on the primary
+        (see &lt;xref linkend="backup-archiving-wal"&gt;).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+ 
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up connections and authentication so that the standby server can
+        successfully connect to the pseudo &lt;literal&gt;replication&lt;/&gt; database of
+        the primary server (see
+        &lt;xref linkend="streaming-replication-authentication"&gt;). Ensure that
+        &lt;xref linkend="guc-listen-addresses"&gt; and &lt;filename&gt;pg_hba.conf&lt;/&gt; are
+        configured appropriately on the primary.
+       &lt;/para&gt;
+       &lt;para&gt;
+        On systems that support the keepalive socket option, setting
+        &lt;xref linkend="guc-tcp-keepalives-idle"&gt;,
+        &lt;xref linkend="guc-tcp-keepalives-interval"&gt; and
+        &lt;xref linkend="guc-tcp-keepalives-count"&gt; helps you to find the
+        troubles with replication (e.g., the network outage or the failure of
+        the standby server) as soon as possible.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set the maximum number of concurrent connections from the standby servers
+        (see &lt;xref linkend="guc-max-wal-senders"&gt; for details).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Enable WAL archiving in the primary server because we need to make a base
+        backup of it later (see &lt;xref linkend="guc-archive-mode"&gt; and
+        &lt;xref linkend="guc-archive-command"&gt; for details).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the primary.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Make a base backup of the primary server (see
+        &lt;xref linkend="backup-base-backup"&gt;), and load this data onto the
+        standby. Note that all files present in &lt;filename&gt;pg_xlog&lt;/&gt;
+        and &lt;filename&gt;pg_xlog/archive_status&lt;/&gt; on the &lt;emphasis&gt;standby&lt;/&gt;
+        server should be removed because they might be obsolete.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up WAL archiving, connections and authentication like the primary
+        server, because the standby server might work as a primary server after
+        failover. Ensure that your settings are consistent with the
+        &lt;emphasis&gt;future&lt;/&gt; environment after the primary and the standby
+        server are interchanged by failover. If you're setting up the standby
+        server for e.g reporting purposes, with no plans to fail over to it,
+        configure the standby accordingly.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Create a recovery command file &lt;filename&gt;recovery.conf&lt;/&gt; in the data
+        directory on the standby server.
+       &lt;/para&gt;
+ 
+       &lt;variablelist id="replication-config-settings" xreflabel="Replication Settings"&gt;
+        &lt;varlistentry id="standby-mode" xreflabel="standby_mode"&gt;
+         &lt;term&gt;&lt;varname&gt;standby_mode&lt;/varname&gt; (&lt;type&gt;boolean&lt;/type&gt;)&lt;/term&gt;
+         &lt;listitem&gt;
+          &lt;para&gt;
+           Specifies whether to start the &lt;productname&gt;PostgreSQL&lt;/&gt; server as
+           a standby. If this parameter is &lt;literal&gt;on&lt;/&gt;, the streaming
+           replication is enabled and the standby server will try to connect
+           to the primary to receive and apply WAL records continuously. The
+           default is &lt;literal&gt;off&lt;/&gt;, which allows only an archive recovery
+           without replication. So, streaming replication requires this
+           parameter to be explicitly set to &lt;literal&gt;on&lt;/&gt;.
+          &lt;/para&gt;
+         &lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+        &lt;varlistentry id="primary-conninfo" xreflabel="primary_conninfo"&gt;
+         &lt;term&gt;&lt;varname&gt;primary_conninfo&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
+         &lt;listitem&gt;
+          &lt;para&gt;
+           Specifies a connection string which is used for the standby server
+           to connect with the primary. This string is in the same format as
+           described in &lt;xref linkend="libpq-connect"&gt;. If any option is
+           unspecified in this string, then the corresponding environment
+           variable (see &lt;xref linkend="libpq-envars"&gt;) is checked. If the
+           environment variable is not set either, then the indicated built-in
+           defaults are used.
+          &lt;/para&gt;
+          &lt;para&gt;
+           The built-in replication requires that a host name (or host address)
+           or port number which the primary server listens on should be
+           specified in this string, respectively. Also ensure that a role with
+           the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt; privileges on the
+           primary is set (see
+           &lt;xref linkend="streaming-replication-authentication"&gt;). Note that
+           the password needs to be set if the primary demands password
+           authentication.
+          &lt;/para&gt;
+         &lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+        &lt;varlistentry id="trigger-file" xreflabel="trigger_file"&gt;
+         &lt;term&gt;&lt;varname&gt;trigger_file&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
+         &lt;listitem&gt;
+          &lt;para&gt;
+           Specifies a trigger file whose presence activates the standby.
+           If no trigger file is specified, the standby never exits
+           recovery.
+          &lt;/para&gt;
+         &lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+       &lt;/variablelist&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the standby. The standby
+        server will go into recovery mode and proceeds to receive WAL records
+        from the primary and apply them continuously.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;/orderedlist&gt;
+     &lt;/para&gt;
+    &lt;/sect2&gt;
+    &lt;sect2 id="streaming-replication-authentication"&gt;
+     &lt;title&gt;Authentication&lt;/title&gt;
+     &lt;para&gt;
+      It's very important that the access privilege for replication are set
+      properly so that only trusted users can read the WAL stream, because it's
+      easy to extract serious information from it.
+     &lt;/para&gt;
+     &lt;para&gt;
+      Only superuser is allowed to connect to the primary as the replication
+      standby. So a role with the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt;
+      privileges needs to be created in the primary.
+     &lt;/para&gt;
+     &lt;para&gt;
+      Client authentication for replication is controlled by the
+      &lt;filename&gt;pg_hba.conf&lt;/&gt; record specifying &lt;literal&gt;replication&lt;/&gt; in the
+      &lt;replaceable&gt;database&lt;/&gt; field. For example, if the standby is running on
+      host IP &lt;literal&gt;192.168.1.100&lt;/&gt; and the superuser's name for replication
+      is &lt;literal&gt;foo&lt;/&gt;, the administrator can add the following line to the
+      &lt;filename&gt;pg_hba.conf&lt;/&gt; file on the primary.
+ 
+ &lt;programlisting&gt;
+ # Allow the user "foo" from host 192.168.1.100 to connect to the primary
+ # as a replication standby if the user's password is correctly supplied.
+ #
+ # TYPE  DATABASE        USER            CIDR-ADDRESS            METHOD
+ host    replication     foo             192.168.1.100/32        md5
+ &lt;/programlisting&gt;
+     &lt;/para&gt;
+     &lt;para&gt;
+      The host name and port number of the primary, user name to connect as,
+      and password are specified in the &lt;filename&gt;recovery.conf&lt;/&gt; file or
+      the corresponding environment variable on the standby.
+      For example, if the primary is running on host IP &lt;literal&gt;192.168.1.50&lt;/&gt;,
+      port &lt;literal&gt;5432&lt;/literal&gt;, the superuser's name for replication is
+      &lt;literal&gt;foo&lt;/&gt;, and the password is &lt;literal&gt;foopass&lt;/&gt;, the administrator
+      can add the following line to the &lt;filename&gt;recovery.conf&lt;/&gt; file on the
+      standby.
+ 
+ &lt;programlisting&gt;
+ # The standby connects to the primary that is running on host 192.168.1.50
+ # and port 5432 as the user "foo" whose password is "foopass".
+ primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
+ &lt;/programlisting&gt;
+     &lt;/para&gt;
+    &lt;/sect2&gt;
+   &lt;/sect1&gt;
+ 
+   &lt;sect1 id="warm-standby-failover"&gt;
+    &lt;title&gt;Failover&lt;/title&gt;
+ 
+    &lt;para&gt;
+     If the primary server fails then the standby server should begin
+     failover procedures.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If the standby server fails then no failover need take place. If the
+     standby server can be restarted, even some time later, then the recovery
+     process can also be immediately restarted, taking advantage of
+     restartable recovery. If the standby server cannot be restarted, then a
+     full new standby server instance should be created.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If the primary server fails and the standby server becomes the
+     new primary, and then the old primary restarts, you must have
+     a mechanism for informing old primary that it is no longer the primary. This is
+     sometimes known as STONITH (Shoot The Other Node In The Head), which is
+     necessary to avoid situations where both systems think they are the
+     primary, which will lead to confusion and ultimately data loss.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Many failover systems use just two systems, the primary and the standby,
+     connected by some kind of heartbeat mechanism to continually verify the
+     connectivity between the two and the viability of the primary. It is
+     also possible to use a third system (called a witness server) to prevent
+     some cases of inappropriate failover, but the additional complexity
+     might not be worthwhile unless it is set up with sufficient care and
+     rigorous testing.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Once failover to the standby occurs, we have only a
+     single server in operation. This is known as a degenerate state.
+     The former standby is now the primary, but the former primary is down
+     and might stay down.  To return to normal operation we must
+     fully recreate a standby server,
+     either on the former primary system when it comes up, or on a third,
+     possibly new, system. Once complete the primary and standby can be
+     considered to have switched roles. Some people choose to use a third
+     server to provide backup for the new primary until the new standby
+     server is recreated,
+     though clearly this complicates the system configuration and
+     operational processes.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     So, switching from primary to standby server can be fast but requires
+     some time to re-prepare the failover cluster. Regular switching from
+     primary to standby is useful, since it allows regular downtime on
+     each system for maintenance. This also serves as a test of the
+     failover mechanism to ensure that it will really work when you need it.
+     Written administration procedures are advised.
+    &lt;/para&gt;
+   &lt;/sect1&gt;
+ 
+  &lt;sect1 id="hot-standby"&gt;
+   &lt;title&gt;Hot Standby&lt;/title&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;Hot Standby&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+    &lt;para&gt;
+     Hot Standby is the term used to describe the ability to connect to
+     the server and run queries while the server is in archive recovery. This
+     is useful for both log shipping replication and for restoring a backup
+     to an exact state with great precision.
+     The term Hot Standby also refers to the ability of the server to move
+     from recovery through to normal running while users continue running
+     queries and/or continue their connections.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Running queries in recovery is in many ways the same as normal running
+     though there are a large number of usage and administrative points
+     to note.
+    &lt;/para&gt;
+ 
+   &lt;sect2 id="hot-standby-users"&gt;
+    &lt;title&gt;User's Overview&lt;/title&gt;
+ 
+    &lt;para&gt;
+     Users can connect to the database while the server is in recovery
+     and perform read-only queries. Read-only access to catalogs and views
+     will also occur as normal.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The data on the standby takes some time to arrive from the primary server
+     so there will be a measurable delay between primary and standby. Running the
+     same query nearly simultaneously on both primary and standby might therefore
+     return differing results. We say that data on the standby is eventually
+     consistent with the primary.
+     Queries executed on the standby will be correct with regard to the transactions
+     that had been recovered at the start of the query, or start of first statement,
+     in the case of serializable transactions. In comparison with the primary,
+     the standby returns query results that could have been obtained on the primary
+     at some exact moment in the past.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     When a transaction is started in recovery, the parameter
+     &lt;varname&gt;transaction_read_only&lt;/&gt; will be forced to be true, regardless of the
+     &lt;varname&gt;default_transaction_read_only&lt;/&gt; setting in &lt;filename&gt;postgresql.conf&lt;/&gt;.
+     It can't be manually set to false either. As a result, all transactions
+     started during recovery will be limited to read-only actions only. In all
+     other ways, connected sessions will appear identical to sessions
+     initiated during normal processing mode. There are no special commands
+     required to initiate a connection at this time, so all interfaces
+     work normally without change. After recovery finishes, the session
+     will allow normal read-write transactions at the start of the next
+     transaction, if these are requested.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Read-only here means "no writes to the permanent database tables".
+     There are no problems with queries that make use of transient sort and
+     work files.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The following actions are allowed
+ 
+     &lt;itemizedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Query access - SELECT, COPY TO including views and SELECT RULEs
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Cursor commands - DECLARE, FETCH, CLOSE,
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Parameters - SHOW, SET, RESET
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Transaction management commands
+         &lt;itemizedlist&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            BEGIN, END, ABORT, START TRANSACTION
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            SAVEPOINT, RELEASE, ROLLBACK TO SAVEPOINT
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            EXCEPTION blocks and other internal subtransactions
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+         &lt;/itemizedlist&gt;
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        LOCK TABLE, though only when explicitly in one of these modes:
+        ACCESS SHARE, ROW SHARE or ROW EXCLUSIVE.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Plans and resources - PREPARE, EXECUTE, DEALLOCATE, DISCARD
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Plugins and extensions - LOAD
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     These actions produce error messages
+ 
+     &lt;itemizedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Data Manipulation Language (DML) - INSERT, UPDATE, DELETE, COPY FROM, TRUNCATE.
+        Note that there are no allowed actions that result in a trigger
+        being executed during recovery.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Data Definition Language (DDL) - CREATE, DROP, ALTER, COMMENT.
+        This also applies to temporary tables currently because currently their
+        definition causes writes to catalog tables.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        SELECT ... FOR SHARE | UPDATE which cause row locks to be written
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        RULEs on SELECT statements that generate DML commands.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        LOCK TABLE, in short default form, since it requests ACCESS EXCLUSIVE MODE.
+        LOCK TABLE that explicitly requests a mode higher than ROW EXCLUSIVE MODE.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Transaction management commands that explicitly set non-read only state
+         &lt;itemizedlist&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+             BEGIN READ WRITE,
+             START TRANSACTION READ WRITE
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+             SET TRANSACTION READ WRITE,
+             SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            SET transaction_read_only = off
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+         &lt;/itemizedlist&gt;
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Two-phase commit commands - PREPARE TRANSACTION, COMMIT PREPARED,
+        ROLLBACK PREPARED because even read-only transactions need to write
+        WAL in the prepare phase (the first phase of two phase commit).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        sequence update - nextval()
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        LISTEN, UNLISTEN, NOTIFY since they currently write to system tables
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Note that current behaviour of read only transactions when not in
+     recovery is to allow the last two actions, so there are small and
+     subtle differences in behaviour between read-only transactions
+     run on standby and during normal running.
+     It is possible that the restrictions on LISTEN, UNLISTEN, NOTIFY and
+     temporary tables may be lifted in a future release, if their internal
+     implementation is altered to make this possible.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If failover or switchover occurs the database will switch to normal
+     processing mode. Sessions will remain connected while the server
+     changes mode. Current transactions will continue, though will remain
+     read-only. After recovery is complete, it will be possible to initiate
+     read-write transactions.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Users will be able to tell whether their session is read-only by
+     issuing SHOW transaction_read_only.  In addition a set of
+     functions &lt;xref linkend="functions-recovery-info-table"&gt; allow users to
+     access information about Hot Standby. These allow you to write
+     functions that are aware of the current state of the database. These
+     can be used to monitor the progress of recovery, or to allow you to
+     write complex programs that restore the database to particular states.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In recovery, transactions will not be permitted to take any table lock
+     higher than RowExclusiveLock. In addition, transactions may never assign
+     a TransactionId and may never write WAL.
+     Any &lt;command&gt;LOCK TABLE&lt;/&gt; command that runs on the standby and requests
+     a specific lock mode higher than ROW EXCLUSIVE MODE will be rejected.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In general queries will not experience lock conflicts with the database
+     changes made by recovery. This is becase recovery follows normal
+     concurrency control mechanisms, known as &lt;acronym&gt;MVCC&lt;/&gt;. There are
+     some types of change that will cause conflicts, covered in the following
+     section.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-conflict"&gt;
+    &lt;title&gt;Handling query conflicts&lt;/title&gt;
+ 
+    &lt;para&gt;
+     The primary and standby nodes are in many ways loosely connected. Actions
+     on the primary will have an effect on the standby. As a result, there is
+     potential for negative interactions or conflicts between them. The easiest
+     conflict to understand is performance: if a huge data load is taking place
+     on the primary then this will generate a similar stream of WAL records on the
+     standby, so standby queries may contend for system resources, such as I/O.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     There are also additional types of conflict that can occur with Hot Standby.
+     These conflicts are &lt;emphasis&gt;hard conflicts&lt;/&gt; in the sense that we may
+     need to cancel queries and in some cases disconnect sessions to resolve them.
+     The user is provided with a number of optional ways to handle these
+     conflicts, though we must first understand the possible reasons behind a conflict.
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Access Exclusive Locks from primary node, including both explicit
+          LOCK commands and various kinds of DDL action
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Dropping tablespaces on the primary while standby queries are using
+          those tablespaces for temporary work files (work_mem overflow)
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Dropping databases on the primary while users are connected to that
+          database on the standby.
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Waiting to acquire buffer cleanup locks
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Early cleanup of data still visible to the current query's snapshot
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Some WAL redo actions will be for DDL actions. These DDL actions are
+     repeating actions that have already committed on the primary node, so
+     they must not fail on the standby node. These DDL locks take priority
+     and will automatically *cancel* any read-only transactions that get in
+     their way, after a grace period. This is similar to the possibility of
+     being canceled by the deadlock detector, but in this case the standby
+     process always wins, since the replayed actions must not fail. This
+     also ensures that replication doesn't fall behind while we wait for a
+     query to complete. Again, we assume that the standby is there for high
+     availability purposes primarily.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     An example of the above would be an Administrator on Primary server
+     runs a &lt;command&gt;DROP TABLE&lt;/&gt; on a table that's currently being queried
+     in the standby server.
+     Clearly the query cannot continue if we let the &lt;command&gt;DROP TABLE&lt;/&gt;
+     proceed. If this situation occurred on the primary, the &lt;command&gt;DROP TABLE&lt;/&gt;
+     would wait until the query has finished. When the query is on the standby
+     and the &lt;command&gt;DROP TABLE&lt;/&gt; is on the primary, the primary doesn't have
+     information about which queries are running on the standby and so the query
+     does not wait on the primary. The WAL change records come through to the
+     standby while the standby query is still running, causing a conflict.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The most common reason for conflict between standby queries and WAL redo is
+     "early cleanup". Normally, &lt;productname&gt;PostgreSQL&lt;/&gt; allows cleanup of old
+     row versions when there are no users who may need to see them to ensure correct
+     visibility of data (the heart of MVCC). If there is a standby query that has
+     been running for longer than any query on the primary then it is possible
+     for old row versions to be removed by either a vacuum or HOT. This will
+     then generate WAL records that, if applied, would remove data on the
+     standby that might *potentially* be required by the standby query.
+     In more technical language, the primary's xmin horizon is later than
+     the standby's xmin horizon, allowing dead rows to be removed.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Experienced users should note that both row version cleanup and row version
+     freezing will potentially conflict with recovery queries. Running a
+     manual &lt;command&gt;VACUUM FREEZE&lt;/&gt; is likely to cause conflicts even on tables
+     with no updated or deleted rows.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     We have a number of choices for resolving query conflicts.  The default
+     is that we wait and hope the query completes. The server will wait
+     automatically until the lag between primary and standby is at most
+     &lt;varname&gt;max_standby_delay&lt;/&gt; seconds. Once that grace period expires,
+     we take one of the following actions:
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          If the conflict is caused by a lock, we cancel the conflicting standby
+          transaction immediately. If the transaction is idle-in-transaction
+          then currently we abort the session instead, though this may change
+          in the future.
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+ 
+        &lt;listitem&gt;
+         &lt;para&gt;
+          If the conflict is caused by cleanup records we tell the standby query
+          that a conflict has occurred and that it must cancel itself to avoid the
+          risk that it silently fails to read relevant data because
+          that data has been removed. (This is regrettably very similar to the
+          much feared and iconic error message "snapshot too old"). Some cleanup
+          records only cause conflict with older queries, though some types of
+          cleanup record affect all queries.
+         &lt;/para&gt;
+ 
+         &lt;para&gt;
+          If cancellation does occur, the query and/or transaction can always
+          be re-executed. The error is dynamic and will not necessarily occur
+          the same way if the query is executed again.
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;varname&gt;max_standby_delay&lt;/&gt; is set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
+     The parameter applies to the server as a whole so if the delay is all used
+     up by a single query then there may be little or no waiting for queries that
+     follow immediately, though they will have benefited equally from the initial
+     waiting period. The server may take time to catch up again before the grace
+     period is available again, though if there is a heavy and constant stream
+     of conflicts it may seldom catch up fully.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Users should be clear that tables that are regularly and heavily updated on
+     primary server will quickly cause cancellation of longer running queries on
+     the standby. In those cases &lt;varname&gt;max_standby_delay&lt;/&gt; can be
+     considered somewhat but not exactly the same as setting
+     &lt;varname&gt;statement_timeout&lt;/&gt;.
+     &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Other remedial actions exist if the number of cancellations is unacceptable.
+     The first option is to connect to primary server and keep a query active
+     for as long as we need to run queries on the standby. This guarantees that
+     a WAL cleanup record is never generated and we don't ever get query
+     conflicts as described above. This could be done using contrib/dblink
+     and pg_sleep(), or via other mechanisms. If you do this, you should note
+     that this will delay cleanup of dead rows by vacuum or HOT and many
+     people may find this undesirable. However, we should remember that
+     primary and standby nodes are linked via the WAL, so this situation is no
+     different to the case where we ran the query on the primary node itself
+     except we have the benefit of off-loading the execution onto the standby.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     It is also possible to set &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; on the primary
+     to defer the cleanup of records by autovacuum, vacuum and HOT. This may allow
+     more time for queries to execute before they are cancelled on the standby,
+     without the need for setting a high &lt;varname&gt;max_standby_delay&lt;/&gt;.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Three-way deadlocks are possible between AccessExclusiveLocks arriving from
+     the primary, cleanup WAL records that require buffer cleanup locks and
+     user requests that are waiting behind replayed AccessExclusiveLocks. Deadlocks
+     are resolved by time-out when we exceed &lt;varname&gt;max_standby_delay&lt;/&gt;.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Dropping tablespaces or databases is discussed in the administrator's
+     section since they are not typical user situations.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-admin"&gt;
+    &lt;title&gt;Administrator's Overview&lt;/title&gt;
+ 
+    &lt;para&gt;
+     If there is a &lt;filename&gt;recovery.conf&lt;/&gt; file present the server will start
+     in Hot Standby mode by default, though &lt;varname&gt;recovery_connections&lt;/&gt; can
+     be disabled via &lt;filename&gt;postgresql.conf&lt;/&gt;, if required. The server may take
+     some time to enable recovery connections since the server must first complete
+     sufficient recovery to provide a consistent state against which queries
+     can run before enabling read only connections. Look for these messages
+     in the server logs
+ 
+ &lt;programlisting&gt;
+ LOG:  initializing recovery connections
+ 
+ ... then some time later ...
+ 
+ LOG:  consistent recovery state reached
+ LOG:  database system is ready to accept read only connections
+ &lt;/programlisting&gt;
+ 
+     Consistency information is recorded once per checkpoint on the primary, as long
+     as &lt;varname&gt;recovery_connections&lt;/&gt; is enabled (on the primary). If this parameter
+     is disabled, it will not be possible to enable recovery connections on the standby.
+     The consistent state can also be delayed in the presence of both of these conditions
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          a write transaction has more than 64 subtransactions
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          very long-lived write transactions
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+ 
+     If you are running file-based log shipping ("warm standby"), you may need
+     to wait until the next WAL file arrives, which could be as long as the
+     &lt;varname&gt;archive_timeout&lt;/&gt; setting on the primary.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The setting of some parameters on the standby will need reconfiguration
+     if they have been changed on the primary. The value on the standby must
+     be equal to or greater than the value on the primary. If these parameters
+     are not set high enough then the standby will not be able to track work
+     correctly from recovering transactions. If these values are set too low the
+     the server will halt. Higher values can then be supplied and the server
+     restarted to begin recovery again.
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          &lt;varname&gt;max_connections&lt;/&gt;
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          &lt;varname&gt;max_prepared_transactions&lt;/&gt;
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          &lt;varname&gt;max_locks_per_transaction&lt;/&gt;
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     It is important that the administrator consider the appropriate setting
+     of &lt;varname&gt;max_standby_delay&lt;/&gt;, set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
+     There is no optimal setting and should be set according to business
+     priorities. For example if the server is primarily tasked as a High
+     Availability server, then you may wish to lower
+     &lt;varname&gt;max_standby_delay&lt;/&gt; or even set it to zero, though that is a
+     very aggressive setting. If the standby server is tasked as an additional
+     server for decision support queries then it may be acceptable to set this
+     to a value of many hours (in seconds).
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Transaction status "hint bits" written on primary are not WAL-logged,
+     so data on standby will likely re-write the hints again on the standby.
+     Thus the main database blocks will produce write I/Os even though
+     all users are read-only; no changes have occurred to the data values
+     themselves.  Users will be able to write large sort temp files and
+     re-generate relcache info files, so there is no part of the database
+     that is truly read-only during hot standby mode. There is no restriction
+     on the use of set returning functions, or other users of tuplestore/tuplesort
+     code. Note also that writes to remote databases will still be possible,
+     even though the transaction is read-only locally.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The following types of administrator command are not accepted
+     during recovery mode
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Data Definition Language (DDL) - e.g. CREATE INDEX
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Privilege and Ownership - GRANT, REVOKE, REASSIGN
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Maintenance commands - ANALYZE, VACUUM, CLUSTER, REINDEX
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Note again that some of these commands are actually allowed during
+     "read only" mode transactions on the primary.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     As a result, you cannot create additional indexes that exist solely
+     on the standby, nor can statistics that exist solely on the standby.
+     If these administrator commands are needed they should be executed
+     on the primary so that the changes will propagate through to the
+     standby.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;function&gt;pg_cancel_backend()&lt;/&gt; will work on user backends, but not the
+     Startup process, which performs recovery. pg_stat_activity does not
+     show an entry for the Startup process, nor do recovering transactions
+     show as active. As a result, pg_prepared_xacts is always empty during
+     recovery. If you wish to resolve in-doubt prepared transactions
+     then look at pg_prepared_xacts on the primary and issue commands to
+     resolve those transactions there.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     pg_locks will show locks held by backends as normal. pg_locks also shows
+     a virtual transaction managed by the Startup process that owns all
+     AccessExclusiveLocks held by transactions being replayed by recovery.
+     Note that Startup process does not acquire locks to
+     make database changes and thus locks other than AccessExclusiveLocks
+     do not show in pg_locks for the Startup process, they are just presumed
+     to exist.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;check_pgsql&lt;/&gt; will work, but it is very simple.
+     &lt;productname&gt;check_postgres&lt;/&gt; will also work, though many some actions
+     could give different or confusing results.
+     e.g. last vacuum time will not be maintained for example, since no
+     vacuum occurs on the standby (though vacuums running on the primary do
+     send their changes to the standby).
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     WAL file control commands will not work during recovery
+     e.g. &lt;function&gt;pg_start_backup&lt;/&gt;, &lt;function&gt;pg_switch_xlog&lt;/&gt; etc..
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Dynamically loadable modules work, including pg_stat_statements.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Advisory locks work normally in recovery, including deadlock detection.
+     Note that advisory locks are never WAL logged, so it is not possible for
+     an advisory lock on either the primary or the standby to conflict with WAL
+     replay. Nor is it possible to acquire an advisory lock on the primary
+     and have it initiate a similar advisory lock on the standby. Advisory
+     locks relate only to a single server on which they are acquired.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Trigger-based replication systems such as &lt;productname&gt;Slony&lt;/&gt;,
+     &lt;productname&gt;Londiste&lt;/&gt; and &lt;productname&gt;Bucardo&lt;/&gt; won't run on the
+     standby at all, though they will run happily on the primary server as
+     long as the changes are not sent to standby servers to be applied.
+     WAL replay is not trigger-based so you cannot relay from the
+     standby to any system that requires additional database writes or
+     relies on the use of triggers.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     New oids cannot be assigned, though some &lt;acronym&gt;UUID&lt;/&gt; generators may still
+     work as long as they do not rely on writing new status to the database.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Currently, temp table creation is not allowed during read only
+     transactions, so in some cases existing scripts will not run correctly.
+     It is possible we may relax that restriction in a later release. This is
+     both a SQL Standard compliance issue and a technical issue.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;command&gt;DROP TABLESPACE&lt;/&gt; can only succeed if the tablespace is empty.
+     Some standby users may be actively using the tablespace via their
+     &lt;varname&gt;temp_tablespaces&lt;/&gt; parameter. If there are temp files in the
+     tablespace we currently cancel all active queries to ensure that temp
+     files are removed, so that we can remove the tablespace and continue with
+     WAL replay.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Running &lt;command&gt;DROP DATABASE&lt;/&gt;, &lt;command&gt;ALTER DATABASE ... SET TABLESPACE&lt;/&gt;,
+     or &lt;command&gt;ALTER DATABASE ... RENAME&lt;/&gt; on primary will generate a log message
+     that will cause all users connected to that database on the standby to be
+     forcibly disconnected. This action occurs immediately, whatever the setting of
+     &lt;varname&gt;max_standby_delay&lt;/&gt;.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In normal running, if you issue &lt;command&gt;DROP USER&lt;/&gt; or &lt;command&gt;DROP ROLE&lt;/&gt;
+     for a role with login capability while that user is still connected then
+     nothing happens to the connected user - they remain connected. The user cannot
+     reconnect however. This behaviour applies in recovery also, so a
+     &lt;command&gt;DROP USER&lt;/&gt; on the primary does not disconnect that user on the standby.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Stats collector is active during recovery. All scans, reads, blocks,
+     index usage etc will all be recorded normally on the standby. Replayed
+     actions will not duplicate their effects on primary, so replaying an
+     insert will not increment the Inserts column of pg_stat_user_tables.
+     The stats file is deleted at start of recovery, so stats from primary
+     and standby will differ; this is considered a feature not a bug.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Autovacuum is not active during recovery, though will start normally
+     at the end of recovery.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Background writer is active during recovery and will perform
+     restartpoints (similar to checkpoints on primary) and normal block
+     cleaning activities. The &lt;command&gt;CHECKPOINT&lt;/&gt; command is accepted during recovery,
+     though performs a restartpoint rather than a new checkpoint.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-parameters"&gt;
+    &lt;title&gt;Hot Standby Parameter Reference&lt;/title&gt;
+ 
+    &lt;para&gt;
+     Various parameters have been mentioned above in the &lt;xref linkend="hot-standby-admin"&gt;
+     and &lt;xref linkend="hot-standby-conflict"&gt; sections.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     On the primary, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
+     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; can be used to enable and control the
+     primary server to assist the successful configuration of Hot Standby servers.
+     &lt;varname&gt;max_standby_delay&lt;/&gt; has no effect if set on the primary.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     On the standby, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
+     &lt;varname&gt;max_standby_delay&lt;/&gt; can be used to enable and control Hot Standby.
+     standby server to assist the successful configuration of Hot Standby servers.
+     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; has no effect during recovery.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-caveats"&gt;
+    &lt;title&gt;Caveats&lt;/title&gt;
+ 
+    &lt;para&gt;
+     At this writing, there are several limitations of Hot Standby.
+     These can and probably will be fixed in future releases:
+ 
+   &lt;itemizedlist&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      Operations on hash indexes are not presently WAL-logged, so
+      replay will not update these indexes.  Hash indexes will not be
+      used for query plans during recovery.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      Full knowledge of running transactions is required before snapshots
+      may be taken. Transactions that take use large numbers of subtransactions
+      (currently greater than 64) will delay the start of read only
+      connections until the completion of the longest running write transaction.
+      If this situation occurs explanatory messages will be sent to server log.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      Valid starting points for recovery connections are generated at each
+      checkpoint on the master. If the standby is shutdown while the master
+      is in a shutdown state it may not be possible to re-enter Hot Standby
+      until the primary is started up so that it generates further starting
+      points in the WAL logs. This is not considered a serious issue
+      because the standby is usually switched into the primary role while
+      the first node is taken down.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      At the end of recovery, AccessExclusiveLocks held by prepared transactions
+      will require twice the normal number of lock table entries. If you plan
+      on running either a large number of concurrent prepared transactions
+      that normally take AccessExclusiveLocks, or you plan on having one
+      large transaction that takes many AccessExclusiveLocks then you are
+      advised to select a larger value of &lt;varname&gt;max_locks_per_transaction&lt;/&gt;,
+      up to, but never more than twice the value of the parameter setting on
+      the primary server in rare extremes. You need not consider this at all if
+      your setting of &lt;varname&gt;max_prepared_transactions&lt;/&gt; is &lt;literal&gt;0&lt;/&gt;.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+   &lt;/itemizedlist&gt;
+ 
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+  &lt;/sect1&gt;
+ 
+   &lt;sect1 id="backup-incremental-updated"&gt;
+    &lt;title&gt;Incrementally Updated Backups&lt;/title&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;incrementally updated backups&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;change accumulation&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+    &lt;para&gt;
+     In a warm standby configuration, it is possible to offload the expense of
+     taking periodic base backups from the primary server; instead base backups
+     can be made by backing
+     up a standby server's files.  This concept is generally known as
+     incrementally updated backups, log change accumulation, or more simply,
+     change accumulation.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If we take a file system backup of the standby server's data
+     directory while it is processing
+     logs shipped from the primary, we will be able to reload that backup and
+     restart the standby's recovery process from the last restart point.
+     We no longer need to keep WAL files from before the standby's restart point.
+     If we need to recover, it will be faster to recover from the incrementally
+     updated backup than from the original base backup.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Since the standby server is not &lt;quote&gt;live&lt;/&gt;, it is not possible to
+     use &lt;function&gt;pg_start_backup()&lt;/&gt; and &lt;function&gt;pg_stop_backup()&lt;/&gt;
+     to manage the backup process; it will be up to you to determine how
+     far back you need to keep WAL segment files to have a recoverable
+     backup.  You can do this by running &lt;application&gt;pg_controldata&lt;/&gt;
+     on the standby server to inspect the control file and determine the
+     current checkpoint WAL location, or by using the
+     &lt;varname&gt;log_checkpoints&lt;/&gt; option to print values to the standby's
+     server log.
+    &lt;/para&gt;
+   &lt;/sect1&gt;
+ 
  &lt;/chapter&gt;
</attachpara></page></attachment></attachments><normalized-references><normalized-message-id>3f0b79eb1002081757j28e8c132qfba1b8a869848f00@mail.gmail.com</normalized-message-id><normalized-in-reply-to>4B6E9A9E.5020202@enterprisedb.com</normalized-in-reply-to><normalized-reference>bddc86151002070220p25facb02p1f25b60755971788@mail.gmail.com</normalized-reference><normalized-reference>bddc86151002070241xf3e9771i397382bd0293144@mail.gmail.com</normalized-reference><normalized-reference>4B6E9A9E.5020202@enterprisedb.com</normalized-reference></normalized-references><body><para depth="0">On Sun, Feb 7, 2010 at 7:49 PM, Heikki Linnakangas
&lt;<email>heikki.linnakangas@enterprisedb.com</email>&gt; wrote:
</para><quote depth="1"><quotepara depth="1">Yeah, as you noticed, the documentation for streaming replication is
currently non-existent. That obviously needs to be fixed. I think we
need to move the existing sections around, and of course add a lot of
documentation for the new streaming replication and hot standby specific
stuff. I proposed a new layout here:

</quotepara><quotepara depth="1"><url>http://archives.postgresql.org/message-id/<email>4B50A600.3090309@enterprisedb.com</email></url>
</quotepara></quote><para depth="0">
The attached patch changes the layout according to your suggestion
(but with a small modification). Here is the new layout:

</para><para depth="0">-------------------------------
Chapter 24. Backup and Restore
24.1. SQL Dump
    24.1.1. Restoring the dump
    24.1.2. Using pg_dumpall
    24.1.3. Handling large databases
24.2. File System Level Backup
24.3. Continuous Archiving and Point-In-Time Recovery (PITR)
    24.3.1. Setting up WAL archiving
    24.3.2. Making a Base Backup
    24.3.3. Recovering using a Continuous Archive Backup
    24.3.4. Timelines
    24.3.5. Tips and Examples
    24.3.6. Caveats
24.4. Migration Between Releases

</para><para depth="0">Chapter 25. High Availability, Load Balancing, and Replication
25.1. Comparison of different solutions
25.2. File-based Log Shipping
    25.2.1. Planning
    25.2.2. Implementation
    25.2.3. Record-based Log Shipping
25.3. Streaming Replication
    25.3.1. Setup
    25.3.2. Authentication
25.4. Failover
25.5. Hot Standby
    25.5.1. User's Overview
    25.5.2. Handling query conflicts
    25.5.3. Administrator's Overview
    25.5.4. Hot Standby Parameter Reference
    25.5.5. Caveats
25.6. Incrementally Updated Backups
</para><para depth="0">-------------------------------

</para><para depth="0">I didn't change the content except adjusting the "sect" and
the "indexterm" tags to new chapter.

</para><para depth="0">If this layout change will have been committed, I'll improve
the SR section.

</para><para depth="0">Regards,

</para><para depth="0">-- 
Fujii Masao
NIPPON TELEGRAPH AND TELEPHONE CORPORATION
NTT Open Source Software Center
</para><para depth="0">*** a/doc/src/sgml/backup.sgml
--- b/doc/src/sgml/backup.sgml
***************
*** 1492,2879 **** archive_command = 'local_backup_script.sh'
    &lt;/sect2&gt;
   &lt;/sect1&gt;

</para><para depth="0">-  &lt;sect1 id="warm-standby"&gt;
-   &lt;title&gt;Warm Standby Servers for High Availability&lt;/title&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;warm standby&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;PITR standby&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;standby server&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;log shipping&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;witness server&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;STONITH&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;high availability&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;para&gt;
-    Continuous archiving can be used to create a &lt;firstterm&gt;high
-    availability&lt;/&gt; (HA) cluster configuration with one or more
-    &lt;firstterm&gt;standby servers&lt;/&gt; ready to take over operations if the
-    primary server fails. This capability is widely referred to as
-    &lt;firstterm&gt;warm standby&lt;/&gt; or &lt;firstterm&gt;log shipping&lt;/&gt;.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    The primary and standby server work together to provide this capability,
-    though the servers are only loosely coupled. The primary server operates
-    in continuous archiving mode, while each standby server operates in
-    continuous recovery mode, reading the WAL files from the primary. No
-    changes to the database tables are required to enable this capability,
-    so it offers low administration overhead compared to some other
-    replication approaches. This configuration also has relatively low
-    performance impact on the primary server.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    Directly moving WAL records from one database server to another
-    is typically described as log shipping. &lt;productname&gt;PostgreSQL&lt;/&gt;
-    implements file-based log shipping, which means that WAL records are
-    transferred one file (WAL segment) at a time. WAL files (16MB) can be
-    shipped easily and cheaply over any distance, whether it be to an
-    adjacent system, another system at the same site, or another system on
-    the far side of the globe. The bandwidth required for this technique
-    varies according to the transaction rate of the primary server.
-    Record-based log shipping is also possible with custom-developed
-    procedures, as discussed in &lt;xref linkend="warm-standby-record"&gt;.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    It should be noted that the log shipping is asynchronous, i.e., the WAL
-    records are shipped after transaction commit. As a result there is a
-    window for data loss should the primary server suffer a catastrophic
-    failure: transactions not yet shipped will be lost.  The length of the
-    window of data loss can be limited by use of the
-    &lt;varname&gt;archive_timeout&lt;/varname&gt; parameter, which can be set as low
-    as a few seconds if required.  However such a low setting will
-    substantially increase the bandwidth required for file shipping.
-    If you need a window of less than a minute or so, it's probably better
-    to consider record-based log shipping.
-   &lt;/para&gt;
- 
-   &lt;para&gt;
-    The standby server is not available for access, since it is continually
-    performing recovery processing. Recovery performance is sufficiently
-    good that the standby will typically be only moments away from full
-    availability once it has been activated. As a result, we refer to this
-    capability as a warm standby configuration that offers high
-    availability. Restoring a server from an archived base backup and
-    rollforward will take considerably longer, so that technique only
-    offers a solution for disaster recovery, not high availability.
-   &lt;/para&gt;
- 
-   &lt;sect2 id="warm-standby-planning"&gt;
-    &lt;title&gt;Planning&lt;/title&gt;
- 
-    &lt;para&gt;
-     It is usually wise to create the primary and standby servers
-     so that they are as similar as possible, at least from the
-     perspective of the database server.  In particular, the path names
-     associated with tablespaces will be passed across unmodified, so both
-     primary and standby servers must have the same mount paths for
-     tablespaces if that feature is used.  Keep in mind that if
-     &lt;xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"&gt;
-     is executed on the primary, any new mount point needed for it must
-     be created on the primary and all standby servers before the command
-     is executed. Hardware need not be exactly the same, but experience shows
-     that maintaining two identical systems is easier than maintaining two
-     dissimilar ones over the lifetime of the application and system.
-     In any case the hardware architecture must be the same &amp;mdash; shipping
-     from, say, a 32-bit to a 64-bit system will not work.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In general, log shipping between servers running different major
-     &lt;productname&gt;PostgreSQL&lt;/&gt; release
-     levels is not possible. It is the policy of the PostgreSQL Global
-     Development Group not to make changes to disk formats during minor release
-     upgrades, so it is likely that running different minor release levels
-     on primary and standby servers will work successfully. However, no
-     formal support for that is offered and you are advised to keep primary
-     and standby servers at the same release level as much as possible.
-     When updating to a new minor release, the safest policy is to update
-     the standby servers first &amp;mdash; a new minor release is more likely
-     to be able to read WAL files from a previous minor release than vice
-     versa.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     There is no special mode required to enable a standby server. The
-     operations that occur on both primary and standby servers are
-     normal continuous archiving and recovery tasks. The only point of
-     contact between the two database servers is the archive of WAL files
-     that both share: primary writing to the archive, standby reading from
-     the archive. Care must be taken to ensure that WAL archives from separate
-     primary servers do not become mixed together or confused. The archive
-     need not be large if it is only required for standby operation.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The magic that makes the two loosely coupled servers work together is
-     simply a &lt;varname&gt;restore_command&lt;/&gt; used on the standby that,
-     when asked for the next WAL file, waits for it to become available from
-     the primary. The &lt;varname&gt;restore_command&lt;/&gt; is specified in the
-     &lt;filename&gt;recovery.conf&lt;/&gt; file on the standby server. Normal recovery
-     processing would request a file from the WAL archive, reporting failure
-     if the file was unavailable.  For standby processing it is normal for
-     the next WAL file to be unavailable, so we must be patient and wait for
-     it to appear. For files ending in &lt;literal&gt;.backup&lt;/&gt; or
-     &lt;literal&gt;.history&lt;/&gt; there is no need to wait, and a non-zero return
-     code must be returned. A waiting &lt;varname&gt;restore_command&lt;/&gt; can be
-     written as a custom script that loops after polling for the existence of
-     the next WAL file. There must also be some way to trigger failover, which
-     should interrupt the &lt;varname&gt;restore_command&lt;/&gt;, break the loop and
-     return a file-not-found error to the standby server. This ends recovery
-     and the standby will then come up as a normal server.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Pseudocode for a suitable &lt;varname&gt;restore_command&lt;/&gt; is:
- &lt;programlisting&gt;
- triggered = false;
- while (!NextWALFileReady() &amp;amp;&amp;amp; !triggered)
- {
-     sleep(100000L);         /* wait for ~0.1 sec */
-     if (CheckForExternalTrigger())
-         triggered = true;
- }
- if (!triggered)
-         CopyWALFileForRecovery();
- &lt;/programlisting&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     A working example of a waiting &lt;varname&gt;restore_command&lt;/&gt; is provided
-     as a &lt;filename&gt;contrib&lt;/&gt; module named &lt;application&gt;pg_standby&lt;/&gt;. It
-     should be used as a reference on how to correctly implement the logic
-     described above. It can also be extended as needed to support specific
-     configurations and environments.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;PostgreSQL&lt;/productname&gt; does not provide the system
-     software required to identify a failure on the primary and notify
-     the standby database server.  Many such tools exist and are well
-     integrated with the operating system facilities required for
-     successful failover, such as IP address migration.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The method for triggering failover is an important part of planning
-     and design. One potential option is the &lt;varname&gt;restore_command&lt;/&gt;
-     command.  It is executed once for each WAL file, but the process
-     running the &lt;varname&gt;restore_command&lt;/&gt; is created and dies for
-     each file, so there is no daemon or server process, and we cannot
-     use signals or a signal handler. Therefore, the
-     &lt;varname&gt;restore_command&lt;/&gt; is not suitable to trigger failover.
-     It is possible to use a simple timeout facility, especially if
-     used in conjunction with a known &lt;varname&gt;archive_timeout&lt;/&gt;
-     setting on the primary. However, this is somewhat error prone
-     since a network problem or busy primary server might be sufficient
-     to initiate failover. A notification mechanism such as the explicit
-     creation of a trigger file is ideal, if this can be arranged.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The size of the WAL archive can be minimized by using the &lt;literal&gt;%r&lt;/&gt;
-     option of the &lt;varname&gt;restore_command&lt;/&gt;. This option specifies the
-     last archive file name that needs to be kept to allow the recovery to
-     restart correctly. This can be used to truncate the archive once
-     files are no longer required, assuming the archive is writable from the
-     standby server.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="warm-standby-config"&gt;
-    &lt;title&gt;Implementation&lt;/title&gt;
- 
-    &lt;para&gt;
-     The short procedure for configuring a standby server is as follows. For
-     full details of each step, refer to previous sections as noted.
-     &lt;orderedlist&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up primary and standby systems as nearly identical as
-        possible, including two identical copies of
-        &lt;productname&gt;PostgreSQL&lt;/&gt; at the same release level.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up continuous archiving from the primary to a WAL archive
-        directory on the standby server. Ensure that
-        &lt;xref linkend="guc-archive-mode"&gt;,
-        &lt;xref linkend="guc-archive-command"&gt; and
-        &lt;xref linkend="guc-archive-timeout"&gt;
-        are set appropriately on the primary
-        (see &lt;xref linkend="backup-archiving-wal"&gt;).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Make a base backup of the primary server (see &lt;xref
-        linkend="backup-base-backup"&gt;), and load this data onto the standby.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Begin recovery on the standby server from the local WAL
-        archive, using a &lt;filename&gt;recovery.conf&lt;/&gt; that specifies a
-        &lt;varname&gt;restore_command&lt;/&gt; that waits as described
-        previously (see &lt;xref linkend="backup-pitr-recovery"&gt;).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-     &lt;/orderedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Recovery treats the WAL archive as read-only, so once a WAL file has
-     been copied to the standby system it can be copied to tape at the same
-     time as it is being read by the standby database server.
-     Thus, running a standby server for high availability can be performed at
-     the same time as files are stored for longer term disaster recovery
-     purposes.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     For testing purposes, it is possible to run both primary and standby
-     servers on the same system. This does not provide any worthwhile
-     improvement in server robustness, nor would it be described as HA.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="warm-standby-failover"&gt;
-    &lt;title&gt;Failover&lt;/title&gt;
- 
-    &lt;para&gt;
-     If the primary server fails then the standby server should begin
-     failover procedures.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If the standby server fails then no failover need take place. If the
-     standby server can be restarted, even some time later, then the recovery
-     process can also be immediately restarted, taking advantage of
-     restartable recovery. If the standby server cannot be restarted, then a
-     full new standby server instance should be created.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If the primary server fails and the standby server becomes the
-     new primary, and then the old primary restarts, you must have
-     a mechanism for informing old primary that it is no longer the primary.<br/>This is
-     sometimes known as STONITH (Shoot The Other Node In The Head), which is
-     necessary to avoid situations where both systems think they are the
-     primary, which will lead to confusion and ultimately data loss.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Many failover systems use just two systems, the primary and the standby,
-     connected by some kind of heartbeat mechanism to continually verify the
-     connectivity between the two and the viability of the primary. It is
-     also possible to use a third system (called a witness server) to prevent
-     some cases of inappropriate failover, but the additional complexity
-     might not be worthwhile unless it is set up with sufficient care and
-     rigorous testing.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Once failover to the standby occurs, we have only a
-     single server in operation. This is known as a degenerate state.
-     The former standby is now the primary, but the former primary is down
-     and might stay down.  To return to normal operation we must
-     fully recreate a standby server,
-     either on the former primary system when it comes up, or on a third,
-     possibly new, system. Once complete the primary and standby can be
-     considered to have switched roles. Some people choose to use a third
-     server to provide backup for the new primary until the new standby
-     server is recreated,
-     though clearly this complicates the system configuration and
-     operational processes.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     So, switching from primary to standby server can be fast but requires
-     some time to re-prepare the failover cluster. Regular switching from
-     primary to standby is useful, since it allows regular downtime on
-     each system for maintenance. This also serves as a test of the
-     failover mechanism to ensure that it will really work when you need it.
-     Written administration procedures are advised.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="warm-standby-record"&gt;
-    &lt;title&gt;Record-based Log Shipping&lt;/title&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;PostgreSQL&lt;/productname&gt; directly supports file-based
-     log shipping as described above. It is also possible to implement
-     record-based log shipping, though this requires custom development.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     An external program can call the &lt;function&gt;pg_xlogfile_name_offset()&lt;/&gt;
-     function (see &lt;xref linkend="functions-admin"&gt;)
-     to find out the file name and the exact byte offset within it of
-     the current end of WAL.  It can then access the WAL file directly
-     and copy the data from the last known end of WAL through the current end
-     over to the standby servers.  With this approach, the window for data
-     loss is the polling cycle time of the copying program, which can be very
-     small, and there is no wasted bandwidth from forcing partially-used
-     segment files to be archived.  Note that the standby servers'
-     &lt;varname&gt;restore_command&lt;/&gt; scripts can only deal with whole WAL files,
-     so the incrementally copied data is not ordinarily made available to
-     the standby servers.  It is of use only when the primary dies &amp;mdash;
-     then the last partial WAL file is fed to the standby before allowing
-     it to come up.  The correct implementation of this process requires
-     cooperation of the &lt;varname&gt;restore_command&lt;/&gt; script with the data
-     copying program.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Starting with &lt;productname&gt;PostgreSQL&lt;/&gt; version 8.5, you can use
-     streaming replication (see &lt;xref linkend="streaming-replication"&gt;) to
-     achieve the same with less effort.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="streaming-replication"&gt;
-    &lt;title&gt;Streaming Replication&lt;/title&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;PostgreSQL&lt;/&gt; includes a simple streaming replication
-     mechanism, which lets the standby server to stay more up-to-date than
-     file-based replication allows. The standby connects to the primary
-     and the primary starts streaming WAL records from where the standby
-     left off, and continues streaming them as they are generated, without
-     waiting for the WAL file to be filled. So with streaming replication,
-     &lt;varname&gt;archive_timeout&lt;/&gt; does not need to be configured.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Streaming replication relies on file-based continuous archiving for
-     making the base backup and for allowing a standby to catch up if it's
-     disconnected from the primary for long enough for the primary to
-     delete old WAL files still required by the standby.
-    &lt;/para&gt;
- 
-    &lt;sect3 id="streaming-replication-setup"&gt;
-     &lt;title&gt;Setup&lt;/title&gt;
-     &lt;para&gt;
-      The short procedure for configuring streaming replication is as follows.
-      For full details of each step, refer to other sections as noted.
-      &lt;orderedlist&gt;
-       &lt;listitem&gt;
-        &lt;para&gt;
-         Set up primary and standby systems as near identically as possible,
-         including two identical copies of &lt;productname&gt;PostgreSQL&lt;/&gt; at the
-         same release level.
-        &lt;/para&gt;
-       &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up continuous archiving from the primary to a WAL archive located
-        in a directory on the standby server. Ensure that
-        &lt;xref linkend="guc-archive-mode"&gt;,
-        &lt;xref linkend="guc-archive-command"&gt; and
-        &lt;xref linkend="guc-archive-timeout"&gt;
-        are set appropriately on the primary
-        (see &lt;xref linkend="backup-archiving-wal"&gt;).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
- 
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up connections and authentication so that the standby server can
-        successfully connect to the pseudo &lt;literal&gt;replication&lt;/&gt; database of
-        the primary server (see
-        &lt;xref linkend="streaming-replication-authentication"&gt;). Ensure that
-        &lt;xref linkend="guc-listen-addresses"&gt; and &lt;filename&gt;pg_hba.conf&lt;/&gt; are
-        configured appropriately on the primary.
-       &lt;/para&gt;
-       &lt;para&gt;
-        On systems that support the keepalive socket option, setting
-        &lt;xref linkend="guc-tcp-keepalives-idle"&gt;,
-        &lt;xref linkend="guc-tcp-keepalives-interval"&gt; and
-        &lt;xref linkend="guc-tcp-keepalives-count"&gt; helps you to find the
-        troubles with replication (e.g., the network outage or the failure of
-        the standby server) as soon as possible.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set the maximum number of concurrent connections from the standby<br/>servers
-        (see &lt;xref linkend="guc-max-wal-senders"&gt; for details).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Enable WAL archiving in the primary server because we need to make a<br/>base
-        backup of it later (see &lt;xref linkend="guc-archive-mode"&gt; and
-        &lt;xref linkend="guc-archive-command"&gt; for details).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the primary.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Make a base backup of the primary server (see
-        &lt;xref linkend="backup-base-backup"&gt;), and load this data onto the
-        standby. Note that all files present in &lt;filename&gt;pg_xlog&lt;/&gt;
-        and &lt;filename&gt;pg_xlog/archive_status&lt;/&gt; on the &lt;emphasis&gt;standby&lt;/&gt;
-        server should be removed because they might be obsolete.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Set up WAL archiving, connections and authentication like the primary
-        server, because the standby server might work as a primary server after
-        failover. Ensure that your settings are consistent with the
-        &lt;emphasis&gt;future&lt;/&gt; environment after the primary and the standby
-        server are interchanged by failover. If you're setting up the standby
-        server for e.g reporting purposes, with no plans to fail over to it,
-        configure the standby accordingly.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Create a recovery command file &lt;filename&gt;recovery.conf&lt;/&gt; in the data
-        directory on the standby server.
-       &lt;/para&gt;
- 
-       &lt;variablelist id="replication-config-settings" xreflabel="Replication<br/>Settings"&gt;
-        &lt;varlistentry id="standby-mode" xreflabel="standby_mode"&gt;
-         &lt;term&gt;&lt;varname&gt;standby_mode&lt;/varname&gt; (&lt;type&gt;boolean&lt;/type&gt;)&lt;/term&gt;
-         &lt;listitem&gt;
-          &lt;para&gt;
-           Specifies whether to start the &lt;productname&gt;PostgreSQL&lt;/&gt; server as
-           a standby. If this parameter is &lt;literal&gt;on&lt;/&gt;, the streaming
-           replication is enabled and the standby server will try to connect
-           to the primary to receive and apply WAL records continuously. The
-           default is &lt;literal&gt;off&lt;/&gt;, which allows only an archive recovery
-           without replication. So, streaming replication requires this
-           parameter to be explicitly set to &lt;literal&gt;on&lt;/&gt;.
-          &lt;/para&gt;
-         &lt;/listitem&gt;
-        &lt;/varlistentry&gt;
-        &lt;varlistentry id="primary-conninfo" xreflabel="primary_conninfo"&gt;
-         &lt;term&gt;&lt;varname&gt;primary_conninfo&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
-         &lt;listitem&gt;
-          &lt;para&gt;
-           Specifies a connection string which is used for the standby server
-           to connect with the primary. This string is in the same format as
-           described in &lt;xref linkend="libpq-connect"&gt;. If any option is
-           unspecified in this string, then the corresponding environment
-           variable (see &lt;xref linkend="libpq-envars"&gt;) is checked. If the
-           environment variable is not set either, then the indicated built-in
-           defaults are used.
-          &lt;/para&gt;
-          &lt;para&gt;
-           The built-in replication requires that a host name (or host address)
-           or port number which the primary server listens on should be
-           specified in this string, respectively. Also ensure that a role with
-           the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt; privileges on the
-           primary is set (see
-           &lt;xref linkend="streaming-replication-authentication"&gt;). Note that
-           the password needs to be set if the primary demands password
-           authentication.
-          &lt;/para&gt;
-         &lt;/listitem&gt;
-        &lt;/varlistentry&gt;
-        &lt;varlistentry id="trigger-file" xreflabel="trigger_file"&gt;
-         &lt;term&gt;&lt;varname&gt;trigger_file&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
-         &lt;listitem&gt;
-          &lt;para&gt;
-           Specifies a trigger file whose presence activates the standby.
-           If no trigger file is specified, the standby never exits
-           recovery.
-          &lt;/para&gt;
-         &lt;/listitem&gt;
-        &lt;/varlistentry&gt;
-       &lt;/variablelist&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the standby. The standby
-        server will go into recovery mode and proceeds to receive WAL records
-        from the primary and apply them continuously.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;/orderedlist&gt;
-     &lt;/para&gt;
-    &lt;/sect3&gt;
-    &lt;sect3 id="streaming-replication-authentication"&gt;
-     &lt;title&gt;Authentication&lt;/title&gt;
-     &lt;para&gt;
-      It's very important that the access privilege for replication are set
-      properly so that only trusted users can read the WAL stream, because it's
-      easy to extract serious information from it.
-     &lt;/para&gt;
-     &lt;para&gt;
-      Only superuser is allowed to connect to the primary as the replication
-      standby. So a role with the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt;
-      privileges needs to be created in the primary.
-     &lt;/para&gt;
-     &lt;para&gt;
-      Client authentication for replication is controlled by the
-      &lt;filename&gt;pg_hba.conf&lt;/&gt; record specifying &lt;literal&gt;replication&lt;/&gt; in the
-      &lt;replaceable&gt;database&lt;/&gt; field. For example, if the standby is running on
-      host IP &lt;literal&gt;192.168.1.100&lt;/&gt; and the superuser's name for<br/>replication
-      is &lt;literal&gt;foo&lt;/&gt;, the administrator can add the following line to the
-      &lt;filename&gt;pg_hba.conf&lt;/&gt; file on the primary.
- 
- &lt;programlisting&gt;
- # Allow the user "foo" from host 192.168.1.100 to connect to the primary
- # as a replication standby if the user's password is correctly supplied.
- #
- # TYPE  DATABASE        USER            CIDR-ADDRESS            METHOD
- host    replication     foo             192.168.1.100/32        md5
- &lt;/programlisting&gt;
-     &lt;/para&gt;
-     &lt;para&gt;
-      The host name and port number of the primary, user name to connect as,
-      and password are specified in the &lt;filename&gt;recovery.conf&lt;/&gt; file or
-      the corresponding environment variable on the standby.
-      For example, if the primary is running on host IP<br/>&lt;literal&gt;192.168.1.50&lt;/&gt;,
-      port &lt;literal&gt;5432&lt;/literal&gt;, the superuser's name for replication is
-      &lt;literal&gt;foo&lt;/&gt;, and the password is &lt;literal&gt;foopass&lt;/&gt;, the<br/>administrator
-      can add the following line to the &lt;filename&gt;recovery.conf&lt;/&gt; file on the
-      standby.
- 
- &lt;programlisting&gt;
- # The standby connects to the primary that is running on host 192.168.1.50
- # and port 5432 as the user "foo" whose password is "foopass".
- primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
- &lt;/programlisting&gt;
-     &lt;/para&gt;
-    &lt;/sect3&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="backup-incremental-updated"&gt;
-    &lt;title&gt;Incrementally Updated Backups&lt;/title&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;incrementally updated backups&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;change accumulation&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-    &lt;para&gt;
-     In a warm standby configuration, it is possible to offload the expense of
-     taking periodic base backups from the primary server; instead base backups
-     can be made by backing
-     up a standby server's files.  This concept is generally known as
-     incrementally updated backups, log change accumulation, or more simply,
-     change accumulation.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If we take a file system backup of the standby server's data
-     directory while it is processing
-     logs shipped from the primary, we will be able to reload that backup and
-     restart the standby's recovery process from the last restart point.
-     We no longer need to keep WAL files from before the standby's restart<br/>point.
-     If we need to recover, it will be faster to recover from the incrementally
-     updated backup than from the original base backup.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Since the standby server is not &lt;quote&gt;live&lt;/&gt;, it is not possible to
-     use &lt;function&gt;pg_start_backup()&lt;/&gt; and &lt;function&gt;pg_stop_backup()&lt;/&gt;
-     to manage the backup process; it will be up to you to determine how
-     far back you need to keep WAL segment files to have a recoverable
-     backup.  You can do this by running &lt;application&gt;pg_controldata&lt;/&gt;
-     on the standby server to inspect the control file and determine the
-     current checkpoint WAL location, or by using the
-     &lt;varname&gt;log_checkpoints&lt;/&gt; option to print values to the standby's
-     server log.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
-  &lt;/sect1&gt;
- 
-  &lt;sect1 id="hot-standby"&gt;
-   &lt;title&gt;Hot Standby&lt;/title&gt;
- 
-   &lt;indexterm zone="backup"&gt;
-    &lt;primary&gt;Hot Standby&lt;/primary&gt;
-   &lt;/indexterm&gt;
- 
-    &lt;para&gt;
-     Hot Standby is the term used to describe the ability to connect to
-     the server and run queries while the server is in archive recovery. This
-     is useful for both log shipping replication and for restoring a backup
-     to an exact state with great precision.
-     The term Hot Standby also refers to the ability of the server to move
-     from recovery through to normal running while users continue running
-     queries and/or continue their connections.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Running queries in recovery is in many ways the same as normal running
-     though there are a large number of usage and administrative points
-     to note.
-    &lt;/para&gt;
- 
-   &lt;sect2 id="hot-standby-users"&gt;
-    &lt;title&gt;User's Overview&lt;/title&gt;
- 
-    &lt;para&gt;
-     Users can connect to the database while the server is in recovery
-     and perform read-only queries. Read-only access to catalogs and views
-     will also occur as normal.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The data on the standby takes some time to arrive from the primary server
-     so there will be a measurable delay between primary and standby. Running<br/>the
-     same query nearly simultaneously on both primary and standby might<br/>therefore
-     return differing results. We say that data on the standby is eventually
-     consistent with the primary.
-     Queries executed on the standby will be correct with regard to the<br/>transactions
-     that had been recovered at the start of the query, or start of first<br/>statement,
-     in the case of serializable transactions. In comparison with the primary,
-     the standby returns query results that could have been obtained on the<br/>primary
-     at some exact moment in the past.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     When a transaction is started in recovery, the parameter
-     &lt;varname&gt;transaction_read_only&lt;/&gt; will be forced to be true, regardless of<br/>the
-     &lt;varname&gt;default_transaction_read_only&lt;/&gt; setting in<br/>&lt;filename&gt;postgresql.conf&lt;/&gt;.
-     It can't be manually set to false either. As a result, all transactions
-     started during recovery will be limited to read-only actions only. In all
-     other ways, connected sessions will appear identical to sessions
-     initiated during normal processing mode. There are no special commands
-     required to initiate a connection at this time, so all interfaces
-     work normally without change. After recovery finishes, the session
-     will allow normal read-write transactions at the start of the next
-     transaction, if these are requested.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Read-only here means "no writes to the permanent database tables".
-     There are no problems with queries that make use of transient sort and
-     work files.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The following actions are allowed
- 
-     &lt;itemizedlist&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Query access - SELECT, COPY TO including views and SELECT RULEs
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Cursor commands - DECLARE, FETCH, CLOSE,
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Parameters - SHOW, SET, RESET
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Transaction management commands
-         &lt;itemizedlist&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            BEGIN, END, ABORT, START TRANSACTION
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            SAVEPOINT, RELEASE, ROLLBACK TO SAVEPOINT
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            EXCEPTION blocks and other internal subtransactions
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-         &lt;/itemizedlist&gt;
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        LOCK TABLE, though only when explicitly in one of these modes:
-        ACCESS SHARE, ROW SHARE or ROW EXCLUSIVE.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Plans and resources - PREPARE, EXECUTE, DEALLOCATE, DISCARD
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Plugins and extensions - LOAD
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-     &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     These actions produce error messages
- 
-     &lt;itemizedlist&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Data Manipulation Language (DML) - INSERT, UPDATE, DELETE, COPY FROM,<br/>TRUNCATE.
-        Note that there are no allowed actions that result in a trigger
-        being executed during recovery.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Data Definition Language (DDL) - CREATE, DROP, ALTER, COMMENT.
-        This also applies to temporary tables currently because currently their
-        definition causes writes to catalog tables.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        SELECT ... FOR SHARE | UPDATE which cause row locks to be written
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        RULEs on SELECT statements that generate DML commands.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        LOCK TABLE, in short default form, since it requests ACCESS EXCLUSIVE<br/>MODE.
-        LOCK TABLE that explicitly requests a mode higher than ROW EXCLUSIVE<br/>MODE.
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Transaction management commands that explicitly set non-read only state
-         &lt;itemizedlist&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-             BEGIN READ WRITE,
-             START TRANSACTION READ WRITE
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-             SET TRANSACTION READ WRITE,
-             SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-          &lt;listitem&gt;
-           &lt;para&gt;
-            SET transaction_read_only = off
-           &lt;/para&gt;
-          &lt;/listitem&gt;
-         &lt;/itemizedlist&gt;
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        Two-phase commit commands - PREPARE TRANSACTION, COMMIT PREPARED,
-        ROLLBACK PREPARED because even read-only transactions need to write
-        WAL in the prepare phase (the first phase of two phase commit).
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        sequence update - nextval()
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-      &lt;listitem&gt;
-       &lt;para&gt;
-        LISTEN, UNLISTEN, NOTIFY since they currently write to system tables
-       &lt;/para&gt;
-      &lt;/listitem&gt;
-     &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Note that current behaviour of read only transactions when not in
-     recovery is to allow the last two actions, so there are small and
-     subtle differences in behaviour between read-only transactions
-     run on standby and during normal running.
-     It is possible that the restrictions on LISTEN, UNLISTEN, NOTIFY and
-     temporary tables may be lifted in a future release, if their internal
-     implementation is altered to make this possible.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     If failover or switchover occurs the database will switch to normal
-     processing mode. Sessions will remain connected while the server
-     changes mode. Current transactions will continue, though will remain
-     read-only. After recovery is complete, it will be possible to initiate
-     read-write transactions.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Users will be able to tell whether their session is read-only by
-     issuing SHOW transaction_read_only.  In addition a set of
-     functions &lt;xref linkend="functions-recovery-info-table"&gt; allow users to
-     access information about Hot Standby. These allow you to write
-     functions that are aware of the current state of the database. These
-     can be used to monitor the progress of recovery, or to allow you to
-     write complex programs that restore the database to particular states.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In recovery, transactions will not be permitted to take any table lock
-     higher than RowExclusiveLock. In addition, transactions may never assign
-     a TransactionId and may never write WAL.
-     Any &lt;command&gt;LOCK TABLE&lt;/&gt; command that runs on the standby and requests
-     a specific lock mode higher than ROW EXCLUSIVE MODE will be rejected.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In general queries will not experience lock conflicts with the database
-     changes made by recovery. This is becase recovery follows normal
-     concurrency control mechanisms, known as &lt;acronym&gt;MVCC&lt;/&gt;. There are
-     some types of change that will cause conflicts, covered in the following
-     section.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-conflict"&gt;
-    &lt;title&gt;Handling query conflicts&lt;/title&gt;
- 
-    &lt;para&gt;
-     The primary and standby nodes are in many ways loosely connected. Actions
-     on the primary will have an effect on the standby. As a result, there is
-     potential for negative interactions or conflicts between them. The easiest
-     conflict to understand is performance: if a huge data load is taking place
-     on the primary then this will generate a similar stream of WAL records on<br/>the
-     standby, so standby queries may contend for system resources, such as I/O.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     There are also additional types of conflict that can occur with Hot<br/>Standby.
-     These conflicts are &lt;emphasis&gt;hard conflicts&lt;/&gt; in the sense that we may
-     need to cancel queries and in some cases disconnect sessions to resolve<br/>them.
-     The user is provided with a number of optional ways to handle these
-     conflicts, though we must first understand the possible reasons behind a<br/>conflict.
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Access Exclusive Locks from primary node, including both explicit
-          LOCK commands and various kinds of DDL action
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Dropping tablespaces on the primary while standby queries are using
-          those tablespaces for temporary work files (work_mem overflow)
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Dropping databases on the primary while users are connected to that
-          database on the standby.
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Waiting to acquire buffer cleanup locks
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Early cleanup of data still visible to the current query's snapshot
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Some WAL redo actions will be for DDL actions. These DDL actions are
-     repeating actions that have already committed on the primary node, so
-     they must not fail on the standby node. These DDL locks take priority
-     and will automatically *cancel* any read-only transactions that get in
-     their way, after a grace period. This is similar to the possibility of
-     being canceled by the deadlock detector, but in this case the standby
-     process always wins, since the replayed actions must not fail. This
-     also ensures that replication doesn't fall behind while we wait for a
-     query to complete. Again, we assume that the standby is there for high
-     availability purposes primarily.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     An example of the above would be an Administrator on Primary server
-     runs a &lt;command&gt;DROP TABLE&lt;/&gt; on a table that's currently being queried
-     in the standby server.
-     Clearly the query cannot continue if we let the &lt;command&gt;DROP TABLE&lt;/&gt;
-     proceed. If this situation occurred on the primary, the &lt;command&gt;DROP<br/>TABLE&lt;/&gt;
-     would wait until the query has finished. When the query is on the standby
-     and the &lt;command&gt;DROP TABLE&lt;/&gt; is on the primary, the primary doesn't have
-     information about which queries are running on the standby and so the<br/>query
-     does not wait on the primary. The WAL change records come through to the
-     standby while the standby query is still running, causing a conflict.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The most common reason for conflict between standby queries and WAL redo<br/>is
-     "early cleanup". Normally, &lt;productname&gt;PostgreSQL&lt;/&gt; allows cleanup of<br/>old
-     row versions when there are no users who may need to see them to ensure<br/>correct
-     visibility of data (the heart of MVCC). If there is a standby query that<br/>has
-     been running for longer than any query on the primary then it is possible
-     for old row versions to be removed by either a vacuum or HOT. This will
-     then generate WAL records that, if applied, would remove data on the
-     standby that might *potentially* be required by the standby query.
-     In more technical language, the primary's xmin horizon is later than
-     the standby's xmin horizon, allowing dead rows to be removed.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Experienced users should note that both row version cleanup and row<br/>version
-     freezing will potentially conflict with recovery queries. Running a
-     manual &lt;command&gt;VACUUM FREEZE&lt;/&gt; is likely to cause conflicts even on<br/>tables
-     with no updated or deleted rows.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     We have a number of choices for resolving query conflicts.  The default
-     is that we wait and hope the query completes. The server will wait
-     automatically until the lag between primary and standby is at most
-     &lt;varname&gt;max_standby_delay&lt;/&gt; seconds. Once that grace period expires,
-     we take one of the following actions:
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          If the conflict is caused by a lock, we cancel the conflicting<br/>standby
-          transaction immediately. If the transaction is idle-in-transaction
-          then currently we abort the session instead, though this may change
-          in the future.
-         &lt;/para&gt;
-        &lt;/listitem&gt;
- 
-        &lt;listitem&gt;
-         &lt;para&gt;
-          If the conflict is caused by cleanup records we tell the standby<br/>query
-          that a conflict has occurred and that it must cancel itself to avoid<br/>the
-          risk that it silently fails to read relevant data because
-          that data has been removed. (This is regrettably very similar to the
-          much feared and iconic error message "snapshot too old"). Some<br/>cleanup
-          records only cause conflict with older queries, though some types of
-          cleanup record affect all queries.
-         &lt;/para&gt;
- 
-         &lt;para&gt;
-          If cancellation does occur, the query and/or transaction can always
-          be re-executed. The error is dynamic and will not necessarily occur
-          the same way if the query is executed again.
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;varname&gt;max_standby_delay&lt;/&gt; is set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
-     The parameter applies to the server as a whole so if the delay is all used
-     up by a single query then there may be little or no waiting for queries<br/>that
-     follow immediately, though they will have benefited equally from the<br/>initial
-     waiting period. The server may take time to catch up again before the<br/>grace
-     period is available again, though if there is a heavy and constant stream
-     of conflicts it may seldom catch up fully.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Users should be clear that tables that are regularly and heavily updated<br/>on
-     primary server will quickly cause cancellation of longer running queries<br/>on
-     the standby. In those cases &lt;varname&gt;max_standby_delay&lt;/&gt; can be
-     considered somewhat but not exactly the same as setting
-     &lt;varname&gt;statement_timeout&lt;/&gt;.
-     &lt;/para&gt;
- 
-    &lt;para&gt;
-     Other remedial actions exist if the number of cancellations is<br/>unacceptable.
-     The first option is to connect to primary server and keep a query active
-     for as long as we need to run queries on the standby. This guarantees that
-     a WAL cleanup record is never generated and we don't ever get query
-     conflicts as described above. This could be done using contrib/dblink
-     and pg_sleep(), or via other mechanisms. If you do this, you should note
-     that this will delay cleanup of dead rows by vacuum or HOT and many
-     people may find this undesirable. However, we should remember that
-     primary and standby nodes are linked via the WAL, so this situation is no
-     different to the case where we ran the query on the primary node itself
-     except we have the benefit of off-loading the execution onto the standby.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     It is also possible to set &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; on the<br/>primary
-     to defer the cleanup of records by autovacuum, vacuum and HOT. This may<br/>allow
-     more time for queries to execute before they are cancelled on the standby,
-     without the need for setting a high &lt;varname&gt;max_standby_delay&lt;/&gt;.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Three-way deadlocks are possible between AccessExclusiveLocks arriving<br/>from
-     the primary, cleanup WAL records that require buffer cleanup locks and
-     user requests that are waiting behind replayed AccessExclusiveLocks.<br/>Deadlocks
-     are resolved by time-out when we exceed &lt;varname&gt;max_standby_delay&lt;/&gt;.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Dropping tablespaces or databases is discussed in the administrator's
-     section since they are not typical user situations.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-admin"&gt;
-    &lt;title&gt;Administrator's Overview&lt;/title&gt;
- 
-    &lt;para&gt;
-     If there is a &lt;filename&gt;recovery.conf&lt;/&gt; file present the server will<br/>start
-     in Hot Standby mode by default, though &lt;varname&gt;recovery_connections&lt;/&gt;<br/>can
-     be disabled via &lt;filename&gt;postgresql.conf&lt;/&gt;, if required. The server may<br/>take
-     some time to enable recovery connections since the server must first<br/>complete
-     sufficient recovery to provide a consistent state against which queries
-     can run before enabling read only connections. Look for these messages
-     in the server logs
- 
- &lt;programlisting&gt;
- LOG:  initializing recovery connections
- 
- ... then some time later ...
- 
- LOG:  consistent recovery state reached
- LOG:  database system is ready to accept read only connections
- &lt;/programlisting&gt;
- 
-     Consistency information is recorded once per checkpoint on the primary, as<br/>long
-     as &lt;varname&gt;recovery_connections&lt;/&gt; is enabled (on the primary). If this<br/>parameter
-     is disabled, it will not be possible to enable recovery connections on the<br/>standby.
-     The consistent state can also be delayed in the presence of both of these<br/>conditions
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          a write transaction has more than 64 subtransactions
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          very long-lived write transactions
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
- 
-     If you are running file-based log shipping ("warm standby"), you may need
-     to wait until the next WAL file arrives, which could be as long as the
-     &lt;varname&gt;archive_timeout&lt;/&gt; setting on the primary.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The setting of some parameters on the standby will need reconfiguration
-     if they have been changed on the primary. The value on the standby must
-     be equal to or greater than the value on the primary. If these parameters
-     are not set high enough then the standby will not be able to track work
-     correctly from recovering transactions. If these values are set too low<br/>the
-     the server will halt. Higher values can then be supplied and the server
-     restarted to begin recovery again.
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          &lt;varname&gt;max_connections&lt;/&gt;
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          &lt;varname&gt;max_prepared_transactions&lt;/&gt;
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          &lt;varname&gt;max_locks_per_transaction&lt;/&gt;
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     It is important that the administrator consider the appropriate setting
-     of &lt;varname&gt;max_standby_delay&lt;/&gt;, set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
-     There is no optimal setting and should be set according to business
-     priorities. For example if the server is primarily tasked as a High
-     Availability server, then you may wish to lower
-     &lt;varname&gt;max_standby_delay&lt;/&gt; or even set it to zero, though that is a
-     very aggressive setting. If the standby server is tasked as an additional
-     server for decision support queries then it may be acceptable to set this
-     to a value of many hours (in seconds).
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Transaction status "hint bits" written on primary are not WAL-logged,
-     so data on standby will likely re-write the hints again on the standby.
-     Thus the main database blocks will produce write I/Os even though
-     all users are read-only; no changes have occurred to the data values
-     themselves.  Users will be able to write large sort temp files and
-     re-generate relcache info files, so there is no part of the database
-     that is truly read-only during hot standby mode. There is no restriction
-     on the use of set returning functions, or other users of<br/>tuplestore/tuplesort
-     code. Note also that writes to remote databases will still be possible,
-     even though the transaction is read-only locally.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     The following types of administrator command are not accepted
-     during recovery mode
- 
-       &lt;itemizedlist&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Data Definition Language (DDL) - e.g. CREATE INDEX
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Privilege and Ownership - GRANT, REVOKE, REASSIGN
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-        &lt;listitem&gt;
-         &lt;para&gt;
-          Maintenance commands - ANALYZE, VACUUM, CLUSTER, REINDEX
-         &lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/itemizedlist&gt;
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Note again that some of these commands are actually allowed during
-     "read only" mode transactions on the primary.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     As a result, you cannot create additional indexes that exist solely
-     on the standby, nor can statistics that exist solely on the standby.
-     If these administrator commands are needed they should be executed
-     on the primary so that the changes will propagate through to the
-     standby.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;function&gt;pg_cancel_backend()&lt;/&gt; will work on user backends, but not the
-     Startup process, which performs recovery. pg_stat_activity does not
-     show an entry for the Startup process, nor do recovering transactions
-     show as active. As a result, pg_prepared_xacts is always empty during
-     recovery. If you wish to resolve in-doubt prepared transactions
-     then look at pg_prepared_xacts on the primary and issue commands to
-     resolve those transactions there.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     pg_locks will show locks held by backends as normal. pg_locks also shows
-     a virtual transaction managed by the Startup process that owns all
-     AccessExclusiveLocks held by transactions being replayed by recovery.
-     Note that Startup process does not acquire locks to
-     make database changes and thus locks other than AccessExclusiveLocks
-     do not show in pg_locks for the Startup process, they are just presumed
-     to exist.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;productname&gt;check_pgsql&lt;/&gt; will work, but it is very simple.
-     &lt;productname&gt;check_postgres&lt;/&gt; will also work, though many some actions
-     could give different or confusing results.
-     e.g. last vacuum time will not be maintained for example, since no
-     vacuum occurs on the standby (though vacuums running on the primary do
-     send their changes to the standby).
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     WAL file control commands will not work during recovery
-     e.g. &lt;function&gt;pg_start_backup&lt;/&gt;, &lt;function&gt;pg_switch_xlog&lt;/&gt; etc..
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Dynamically loadable modules work, including pg_stat_statements.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Advisory locks work normally in recovery, including deadlock detection.
-     Note that advisory locks are never WAL logged, so it is not possible for
-     an advisory lock on either the primary or the standby to conflict with WAL
-     replay. Nor is it possible to acquire an advisory lock on the primary
-     and have it initiate a similar advisory lock on the standby. Advisory
-     locks relate only to a single server on which they are acquired.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Trigger-based replication systems such as &lt;productname&gt;Slony&lt;/&gt;,
-     &lt;productname&gt;Londiste&lt;/&gt; and &lt;productname&gt;Bucardo&lt;/&gt; won't run on the
-     standby at all, though they will run happily on the primary server as
-     long as the changes are not sent to standby servers to be applied.
-     WAL replay is not trigger-based so you cannot relay from the
-     standby to any system that requires additional database writes or
-     relies on the use of triggers.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     New oids cannot be assigned, though some &lt;acronym&gt;UUID&lt;/&gt; generators may<br/>still
-     work as long as they do not rely on writing new status to the database.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Currently, temp table creation is not allowed during read only
-     transactions, so in some cases existing scripts will not run correctly.
-     It is possible we may relax that restriction in a later release. This is
-     both a SQL Standard compliance issue and a technical issue.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     &lt;command&gt;DROP TABLESPACE&lt;/&gt; can only succeed if the tablespace is empty.
-     Some standby users may be actively using the tablespace via their
-     &lt;varname&gt;temp_tablespaces&lt;/&gt; parameter. If there are temp files in the
-     tablespace we currently cancel all active queries to ensure that temp
-     files are removed, so that we can remove the tablespace and continue with
-     WAL replay.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Running &lt;command&gt;DROP DATABASE&lt;/&gt;, &lt;command&gt;ALTER DATABASE ... SET<br/>TABLESPACE&lt;/&gt;,
-     or &lt;command&gt;ALTER DATABASE ... RENAME&lt;/&gt; on primary will generate a log<br/>message
-     that will cause all users connected to that database on the standby to be
-     forcibly disconnected. This action occurs immediately, whatever the<br/>setting of
-     &lt;varname&gt;max_standby_delay&lt;/&gt;.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     In normal running, if you issue &lt;command&gt;DROP USER&lt;/&gt; or &lt;command&gt;DROP<br/>ROLE&lt;/&gt;
-     for a role with login capability while that user is still connected then
-     nothing happens to the connected user - they remain connected. The user<br/>cannot
-     reconnect however. This behaviour applies in recovery also, so a
-     &lt;command&gt;DROP USER&lt;/&gt; on the primary does not disconnect that user on the<br/>standby.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Stats collector is active during recovery. All scans, reads, blocks,
-     index usage etc will all be recorded normally on the standby. Replayed
-     actions will not duplicate their effects on primary, so replaying an
-     insert will not increment the Inserts column of pg_stat_user_tables.
-     The stats file is deleted at start of recovery, so stats from primary
-     and standby will differ; this is considered a feature not a bug.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Autovacuum is not active during recovery, though will start normally
-     at the end of recovery.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     Background writer is active during recovery and will perform
-     restartpoints (similar to checkpoints on primary) and normal block
-     cleaning activities. The &lt;command&gt;CHECKPOINT&lt;/&gt; command is accepted during<br/>recovery,
-     though performs a restartpoint rather than a new checkpoint.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-parameters"&gt;
-    &lt;title&gt;Hot Standby Parameter Reference&lt;/title&gt;
- 
-    &lt;para&gt;
-     Various parameters have been mentioned above in the &lt;xref<br/>linkend="hot-standby-admin"&gt;
-     and &lt;xref linkend="hot-standby-conflict"&gt; sections.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     On the primary, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
-     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; can be used to enable and control the
-     primary server to assist the successful configuration of Hot Standby<br/>servers.
-     &lt;varname&gt;max_standby_delay&lt;/&gt; has no effect if set on the primary.
-    &lt;/para&gt;
- 
-    &lt;para&gt;
-     On the standby, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
-     &lt;varname&gt;max_standby_delay&lt;/&gt; can be used to enable and control Hot<br/>Standby.
-     standby server to assist the successful configuration of Hot Standby<br/>servers.
-     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; has no effect during recovery.
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-   &lt;sect2 id="hot-standby-caveats"&gt;
-    &lt;title&gt;Caveats&lt;/title&gt;
- 
-    &lt;para&gt;
-     At this writing, there are several limitations of Hot Standby.
-     These can and probably will be fixed in future releases:
- 
-   &lt;itemizedlist&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      Operations on hash indexes are not presently WAL-logged, so
-      replay will not update these indexes.  Hash indexes will not be
-      used for query plans during recovery.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      Full knowledge of running transactions is required before snapshots
-      may be taken. Transactions that take use large numbers of subtransactions
-      (currently greater than 64) will delay the start of read only
-      connections until the completion of the longest running write<br/>transaction.
-      If this situation occurs explanatory messages will be sent to server log.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      Valid starting points for recovery connections are generated at each
-      checkpoint on the master. If the standby is shutdown while the master
-      is in a shutdown state it may not be possible to re-enter Hot Standby
-      until the primary is started up so that it generates further starting
-      points in the WAL logs. This is not considered a serious issue
-      because the standby is usually switched into the primary role while
-      the first node is taken down.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
-     &lt;para&gt;
-      At the end of recovery, AccessExclusiveLocks held by prepared<br/>transactions
-      will require twice the normal number of lock table entries. If you plan
-      on running either a large number of concurrent prepared transactions
-      that normally take AccessExclusiveLocks, or you plan on having one
-      large transaction that takes many AccessExclusiveLocks then you are
-      advised to select a larger value of<br/>&lt;varname&gt;max_locks_per_transaction&lt;/&gt;,
-      up to, but never more than twice the value of the parameter setting on
-      the primary server in rare extremes. You need not consider this at all if
-      your setting of &lt;varname&gt;max_prepared_transactions&lt;/&gt; is &lt;literal&gt;0&lt;/&gt;.
-     &lt;/para&gt;
-    &lt;/listitem&gt;
-   &lt;/itemizedlist&gt;
- 
-    &lt;/para&gt;
-   &lt;/sect2&gt;
- 
-  &lt;/sect1&gt;
- 
   &lt;sect1 id="migration"&gt;
    &lt;title&gt;Migration Between Releases&lt;/title&gt;

</para><para depth="0">--- 1492,1497 ----
*** a/doc/src/sgml/high-availability.sgml
--- b/doc/src/sgml/high-availability.sgml
***************
*** 79,84 ****
--- 79,87 ----
    also available.
   &lt;/para&gt;

</para><para depth="0">+  &lt;sect1 id="different-replication-solutions"&gt;
+  &lt;title&gt;Comparison of different solutions&lt;/title&gt;
+ 
   &lt;variablelist&gt;

</para><para depth="0">    &lt;varlistentry&gt;
***************
*** 450,453 **** protocol to make nodes agree on a serializable transactional<br/>order.
--- 453,1840 ----

</para><para depth="0">   &lt;/variablelist&gt;

</para><footer type="legalese" depth="0">+  &lt;/sect1&gt;
+ 
+  &lt;sect1 id="warm-standby"&gt;
+   &lt;title&gt;File-based Log Shipping&lt;/title&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;warm standby&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;PITR standby&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;standby server&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;log shipping&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;witness server&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;STONITH&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;para&gt;
+    Continuous archiving can be used to create a &lt;firstterm&gt;high
+    availability&lt;/&gt; (HA) cluster configuration with one or more
+    &lt;firstterm&gt;standby servers&lt;/&gt; ready to take over operations if the
+    primary server fails. This capability is widely referred to as
+    &lt;firstterm&gt;warm standby&lt;/&gt; or &lt;firstterm&gt;log shipping&lt;/&gt;.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    The primary and standby server work together to provide this capability,
+    though the servers are only loosely coupled. The primary server operates
+    in continuous archiving mode, while each standby server operates in
+    continuous recovery mode, reading the WAL files from the primary. No
+    changes to the database tables are required to enable this capability,
+    so it offers low administration overhead compared to some other
+    replication approaches. This configuration also has relatively low
+    performance impact on the primary server.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    Directly moving WAL records from one database server to another
+    is typically described as log shipping. &lt;productname&gt;PostgreSQL&lt;/&gt;
+    implements file-based log shipping, which means that WAL records are
+    transferred one file (WAL segment) at a time. WAL files (16MB) can be
+    shipped easily and cheaply over any distance, whether it be to an
+    adjacent system, another system at the same site, or another system on
+    the far side of the globe. The bandwidth required for this technique
+    varies according to the transaction rate of the primary server.
+    Record-based log shipping is also possible with custom-developed
+    procedures, as discussed in &lt;xref linkend="warm-standby-record"&gt;.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    It should be noted that the log shipping is asynchronous, i.e., the WAL
+    records are shipped after transaction commit. As a result there is a
+    window for data loss should the primary server suffer a catastrophic
+    failure: transactions not yet shipped will be lost.  The length of the
+    window of data loss can be limited by use of the
+    &lt;varname&gt;archive_timeout&lt;/varname&gt; parameter, which can be set as low
+    as a few seconds if required.  However such a low setting will
+    substantially increase the bandwidth required for file shipping.
+    If you need a window of less than a minute or so, it's probably better
+    to consider record-based log shipping.
+   &lt;/para&gt;
+ 
+   &lt;para&gt;
+    The standby server is not available for access, since it is continually
+    performing recovery processing. Recovery performance is sufficiently
+    good that the standby will typically be only moments away from full
+    availability once it has been activated. As a result, we refer to this
+    capability as a warm standby configuration that offers high
+    availability. Restoring a server from an archived base backup and
+    rollforward will take considerably longer, so that technique only
+    offers a solution for disaster recovery, not high availability.
+   &lt;/para&gt;
+ 
+   &lt;sect2 id="warm-standby-planning"&gt;
+    &lt;title&gt;Planning&lt;/title&gt;
+ 
+    &lt;para&gt;
+     It is usually wise to create the primary and standby servers
+     so that they are as similar as possible, at least from the
+     perspective of the database server.  In particular, the path names
+     associated with tablespaces will be passed across unmodified, so both
+     primary and standby servers must have the same mount paths for
+     tablespaces if that feature is used.  Keep in mind that if
+     &lt;xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"&gt;
+     is executed on the primary, any new mount point needed for it must
+     be created on the primary and all standby servers before the command
+     is executed. Hardware need not be exactly the same, but experience shows
+     that maintaining two identical systems is easier than maintaining two
+     dissimilar ones over the lifetime of the application and system.
+     In any case the hardware architecture must be the same &amp;mdash; shipping
+     from, say, a 32-bit to a 64-bit system will not work.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In general, log shipping between servers running different major
+     &lt;productname&gt;PostgreSQL&lt;/&gt; release
+     levels is not possible. It is the policy of the PostgreSQL Global
+     Development Group not to make changes to disk formats during minor release
+     upgrades, so it is likely that running different minor release levels
+     on primary and standby servers will work successfully. However, no
+     formal support for that is offered and you are advised to keep primary
+     and standby servers at the same release level as much as possible.
+     When updating to a new minor release, the safest policy is to update
+     the standby servers first &amp;mdash; a new minor release is more likely
+     to be able to read WAL files from a previous minor release than vice
+     versa.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     There is no special mode required to enable a standby server. The
+     operations that occur on both primary and standby servers are
+     normal continuous archiving and recovery tasks. The only point of
+     contact between the two database servers is the archive of WAL files
+     that both share: primary writing to the archive, standby reading from
+     the archive. Care must be taken to ensure that WAL archives from separate
+     primary servers do not become mixed together or confused. The archive
+     need not be large if it is only required for standby operation.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The magic that makes the two loosely coupled servers work together is
+     simply a &lt;varname&gt;restore_command&lt;/&gt; used on the standby that,
+     when asked for the next WAL file, waits for it to become available from
+     the primary. The &lt;varname&gt;restore_command&lt;/&gt; is specified in the
+     &lt;filename&gt;recovery.conf&lt;/&gt; file on the standby server. Normal recovery
+     processing would request a file from the WAL archive, reporting failure
+     if the file was unavailable.  For standby processing it is normal for
+     the next WAL file to be unavailable, so we must be patient and wait for
+     it to appear. For files ending in &lt;literal&gt;.backup&lt;/&gt; or
+     &lt;literal&gt;.history&lt;/&gt; there is no need to wait, and a non-zero return
+     code must be returned. A waiting &lt;varname&gt;restore_command&lt;/&gt; can be
+     written as a custom script that loops after polling for the existence of
+     the next WAL file. There must also be some way to trigger failover, which
+     should interrupt the &lt;varname&gt;restore_command&lt;/&gt;, break the loop and
+     return a file-not-found error to the standby server. This ends recovery
+     and the standby will then come up as a normal server.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Pseudocode for a suitable &lt;varname&gt;restore_command&lt;/&gt; is:
+ &lt;programlisting&gt;
+ triggered = false;
+ while (!NextWALFileReady() &amp;amp;&amp;amp; !triggered)
+ {
+     sleep(100000L);         /* wait for ~0.1 sec */
+     if (CheckForExternalTrigger())
+         triggered = true;
+ }
+ if (!triggered)
+         CopyWALFileForRecovery();
+ &lt;/programlisting&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     A working example of a waiting &lt;varname&gt;restore_command&lt;/&gt; is provided
+     as a &lt;filename&gt;contrib&lt;/&gt; module named &lt;application&gt;pg_standby&lt;/&gt;. It
+     should be used as a reference on how to correctly implement the logic
+     described above. It can also be extended as needed to support specific
+     configurations and environments.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;PostgreSQL&lt;/productname&gt; does not provide the system
+     software required to identify a failure on the primary and notify
+     the standby database server.  Many such tools exist and are well
+     integrated with the operating system facilities required for
+     successful failover, such as IP address migration.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The method for triggering failover is an important part of planning
+     and design. One potential option is the &lt;varname&gt;restore_command&lt;/&gt;
+     command.  It is executed once for each WAL file, but the process
+     running the &lt;varname&gt;restore_command&lt;/&gt; is created and dies for
+     each file, so there is no daemon or server process, and we cannot
+     use signals or a signal handler. Therefore, the
+     &lt;varname&gt;restore_command&lt;/&gt; is not suitable to trigger failover.
+     It is possible to use a simple timeout facility, especially if
+     used in conjunction with a known &lt;varname&gt;archive_timeout&lt;/&gt;
+     setting on the primary. However, this is somewhat error prone
+     since a network problem or busy primary server might be sufficient
+     to initiate failover. A notification mechanism such as the explicit
+     creation of a trigger file is ideal, if this can be arranged.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The size of the WAL archive can be minimized by using the &lt;literal&gt;%r&lt;/&gt;
+     option of the &lt;varname&gt;restore_command&lt;/&gt;. This option specifies the
+     last archive file name that needs to be kept to allow the recovery to
+     restart correctly. This can be used to truncate the archive once
+     files are no longer required, assuming the archive is writable from the
+     standby server.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="warm-standby-config"&gt;
+    &lt;title&gt;Implementation&lt;/title&gt;
+ 
+    &lt;para&gt;
+     The short procedure for configuring a standby server is as follows. For
+     full details of each step, refer to previous sections as noted.
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up primary and standby systems as nearly identical as
+        possible, including two identical copies of
+        &lt;productname&gt;PostgreSQL&lt;/&gt; at the same release level.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up continuous archiving from the primary to a WAL archive
+        directory on the standby server. Ensure that
+        &lt;xref linkend="guc-archive-mode"&gt;,
+        &lt;xref linkend="guc-archive-command"&gt; and
+        &lt;xref linkend="guc-archive-timeout"&gt;
+        are set appropriately on the primary
+        (see &lt;xref linkend="backup-archiving-wal"&gt;).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Make a base backup of the primary server (see &lt;xref
+        linkend="backup-base-backup"&gt;), and load this data onto the standby.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Begin recovery on the standby server from the local WAL
+        archive, using a &lt;filename&gt;recovery.conf&lt;/&gt; that specifies a
+        &lt;varname&gt;restore_command&lt;/&gt; that waits as described
+        previously (see &lt;xref linkend="backup-pitr-recovery"&gt;).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Recovery treats the WAL archive as read-only, so once a WAL file has
+     been copied to the standby system it can be copied to tape at the same
+     time as it is being read by the standby database server.
+     Thus, running a standby server for high availability can be performed at
+     the same time as files are stored for longer term disaster recovery
+     purposes.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     For testing purposes, it is possible to run both primary and standby
+     servers on the same system. This does not provide any worthwhile
+     improvement in server robustness, nor would it be described as HA.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="warm-standby-record"&gt;
+    &lt;title&gt;Record-based Log Shipping&lt;/title&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;PostgreSQL&lt;/productname&gt; directly supports file-based
+     log shipping as described above. It is also possible to implement
+     record-based log shipping, though this requires custom development.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     An external program can call the &lt;function&gt;pg_xlogfile_name_offset()&lt;/&gt;
+     function (see &lt;xref linkend="functions-admin"&gt;)
+     to find out the file name and the exact byte offset within it of
+     the current end of WAL.  It can then access the WAL file directly
+     and copy the data from the last known end of WAL through the current end
+     over to the standby servers.  With this approach, the window for data
+     loss is the polling cycle time of the copying program, which can be very
+     small, and there is no wasted bandwidth from forcing partially-used
+     segment files to be archived.  Note that the standby servers'
+     &lt;varname&gt;restore_command&lt;/&gt; scripts can only deal with whole WAL files,
+     so the incrementally copied data is not ordinarily made available to
+     the standby servers.  It is of use only when the primary dies &amp;mdash;
+     then the last partial WAL file is fed to the standby before allowing
+     it to come up.  The correct implementation of this process requires
+     cooperation of the &lt;varname&gt;restore_command&lt;/&gt; script with the data
+     copying program.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Starting with &lt;productname&gt;PostgreSQL&lt;/&gt; version 8.5, you can use
+     streaming replication (see &lt;xref linkend="streaming-replication"&gt;) to
+     achieve the same with less effort.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+  &lt;/sect1&gt;
+ 
+   &lt;sect1 id="streaming-replication"&gt;
+    &lt;title&gt;Streaming Replication&lt;/title&gt;
+ 
+    &lt;indexterm zone="high-availability"&gt;
+     &lt;primary&gt;Streaming Replication&lt;/primary&gt;
+    &lt;/indexterm&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;PostgreSQL&lt;/&gt; includes a simple streaming replication
+     mechanism, which lets the standby server to stay more up-to-date than
+     file-based replication allows. The standby connects to the primary
+     and the primary starts streaming WAL records from where the standby
+     left off, and continues streaming them as they are generated, without
+     waiting for the WAL file to be filled. So with streaming replication,
+     &lt;varname&gt;archive_timeout&lt;/&gt; does not need to be configured.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Streaming replication relies on file-based continuous archiving for
+     making the base backup and for allowing a standby to catch up if it's
+     disconnected from the primary for long enough for the primary to
+     delete old WAL files still required by the standby.
+    &lt;/para&gt;
+ 
+    &lt;sect2 id="streaming-replication-setup"&gt;
+     &lt;title&gt;Setup&lt;/title&gt;
+     &lt;para&gt;
+      The short procedure for configuring streaming replication is as follows.
+      For full details of each step, refer to other sections as noted.
+      &lt;orderedlist&gt;
+       &lt;listitem&gt;
+        &lt;para&gt;
+         Set up primary and standby systems as near identically as possible,
+         including two identical copies of &lt;productname&gt;PostgreSQL&lt;/&gt; at the
+         same release level.
+        &lt;/para&gt;
+       &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up continuous archiving from the primary to a WAL archive located
+        in a directory on the standby server. Ensure that
+        &lt;xref linkend="guc-archive-mode"&gt;,
+        &lt;xref linkend="guc-archive-command"&gt; and
+        &lt;xref linkend="guc-archive-timeout"&gt;
+        are set appropriately on the primary
+        (see &lt;xref linkend="backup-archiving-wal"&gt;).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+ 
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up connections and authentication so that the standby server can
+        successfully connect to the pseudo &lt;literal&gt;replication&lt;/&gt; database of
+        the primary server (see
+        &lt;xref linkend="streaming-replication-authentication"&gt;). Ensure that
+        &lt;xref linkend="guc-listen-addresses"&gt; and &lt;filename&gt;pg_hba.conf&lt;/&gt; are
+        configured appropriately on the primary.
+       &lt;/para&gt;
+       &lt;para&gt;
+        On systems that support the keepalive socket option, setting
+        &lt;xref linkend="guc-tcp-keepalives-idle"&gt;,
+        &lt;xref linkend="guc-tcp-keepalives-interval"&gt; and
+        &lt;xref linkend="guc-tcp-keepalives-count"&gt; helps you to find the
+        troubles with replication (e.g., the network outage or the failure of
+        the standby server) as soon as possible.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set the maximum number of concurrent connections from the standby<br/>servers
+        (see &lt;xref linkend="guc-max-wal-senders"&gt; for details).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Enable WAL archiving in the primary server because we need to make a<br/>base
+        backup of it later (see &lt;xref linkend="guc-archive-mode"&gt; and
+        &lt;xref linkend="guc-archive-command"&gt; for details).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the primary.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Make a base backup of the primary server (see
+        &lt;xref linkend="backup-base-backup"&gt;), and load this data onto the
+        standby. Note that all files present in &lt;filename&gt;pg_xlog&lt;/&gt;
+        and &lt;filename&gt;pg_xlog/archive_status&lt;/&gt; on the &lt;emphasis&gt;standby&lt;/&gt;
+        server should be removed because they might be obsolete.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Set up WAL archiving, connections and authentication like the primary
+        server, because the standby server might work as a primary server after
+        failover. Ensure that your settings are consistent with the
+        &lt;emphasis&gt;future&lt;/&gt; environment after the primary and the standby
+        server are interchanged by failover. If you're setting up the standby
+        server for e.g reporting purposes, with no plans to fail over to it,
+        configure the standby accordingly.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Create a recovery command file &lt;filename&gt;recovery.conf&lt;/&gt; in the data
+        directory on the standby server.
+       &lt;/para&gt;
+ 
+       &lt;variablelist id="replication-config-settings" xreflabel="Replication<br/>Settings"&gt;
+        &lt;varlistentry id="standby-mode" xreflabel="standby_mode"&gt;
+         &lt;term&gt;&lt;varname&gt;standby_mode&lt;/varname&gt; (&lt;type&gt;boolean&lt;/type&gt;)&lt;/term&gt;
+         &lt;listitem&gt;
+          &lt;para&gt;
+           Specifies whether to start the &lt;productname&gt;PostgreSQL&lt;/&gt; server as
+           a standby. If this parameter is &lt;literal&gt;on&lt;/&gt;, the streaming
+           replication is enabled and the standby server will try to connect
+           to the primary to receive and apply WAL records continuously. The
+           default is &lt;literal&gt;off&lt;/&gt;, which allows only an archive recovery
+           without replication. So, streaming replication requires this
+           parameter to be explicitly set to &lt;literal&gt;on&lt;/&gt;.
+          &lt;/para&gt;
+         &lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+        &lt;varlistentry id="primary-conninfo" xreflabel="primary_conninfo"&gt;
+         &lt;term&gt;&lt;varname&gt;primary_conninfo&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
+         &lt;listitem&gt;
+          &lt;para&gt;
+           Specifies a connection string which is used for the standby server
+           to connect with the primary. This string is in the same format as
+           described in &lt;xref linkend="libpq-connect"&gt;. If any option is
+           unspecified in this string, then the corresponding environment
+           variable (see &lt;xref linkend="libpq-envars"&gt;) is checked. If the
+           environment variable is not set either, then the indicated built-in
+           defaults are used.
+          &lt;/para&gt;
+          &lt;para&gt;
+           The built-in replication requires that a host name (or host address)
+           or port number which the primary server listens on should be
+           specified in this string, respectively. Also ensure that a role with
+           the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt; privileges on the
+           primary is set (see
+           &lt;xref linkend="streaming-replication-authentication"&gt;). Note that
+           the password needs to be set if the primary demands password
+           authentication.
+          &lt;/para&gt;
+         &lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+        &lt;varlistentry id="trigger-file" xreflabel="trigger_file"&gt;
+         &lt;term&gt;&lt;varname&gt;trigger_file&lt;/varname&gt; (&lt;type&gt;string&lt;/type&gt;)&lt;/term&gt;
+         &lt;listitem&gt;
+          &lt;para&gt;
+           Specifies a trigger file whose presence activates the standby.
+           If no trigger file is specified, the standby never exits
+           recovery.
+          &lt;/para&gt;
+         &lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+       &lt;/variablelist&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Start the &lt;productname&gt;PostgreSQL&lt;/&gt; server on the standby. The standby
+        server will go into recovery mode and proceeds to receive WAL records
+        from the primary and apply them continuously.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;/orderedlist&gt;
+     &lt;/para&gt;
+    &lt;/sect2&gt;
+    &lt;sect2 id="streaming-replication-authentication"&gt;
+     &lt;title&gt;Authentication&lt;/title&gt;
+     &lt;para&gt;
+      It's very important that the access privilege for replication are set
+      properly so that only trusted users can read the WAL stream, because it's
+      easy to extract serious information from it.
+     &lt;/para&gt;
+     &lt;para&gt;
+      Only superuser is allowed to connect to the primary as the replication
+      standby. So a role with the &lt;literal&gt;SUPERUSER&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt;
+      privileges needs to be created in the primary.
+     &lt;/para&gt;
+     &lt;para&gt;
+      Client authentication for replication is controlled by the
+      &lt;filename&gt;pg_hba.conf&lt;/&gt; record specifying &lt;literal&gt;replication&lt;/&gt; in the
+      &lt;replaceable&gt;database&lt;/&gt; field. For example, if the standby is running on
+      host IP &lt;literal&gt;192.168.1.100&lt;/&gt; and the superuser's name for<br/>replication
+      is &lt;literal&gt;foo&lt;/&gt;, the administrator can add the following line to the
+      &lt;filename&gt;pg_hba.conf&lt;/&gt; file on the primary.
+ 
+ &lt;programlisting&gt;
+ # Allow the user "foo" from host 192.168.1.100 to connect to the primary
+ # as a replication standby if the user's password is correctly supplied.
+ #
+ # TYPE  DATABASE        USER            CIDR-ADDRESS            METHOD
+ host    replication     foo             192.168.1.100/32        md5
+ &lt;/programlisting&gt;
+     &lt;/para&gt;
+     &lt;para&gt;
+      The host name and port number of the primary, user name to connect as,
+      and password are specified in the &lt;filename&gt;recovery.conf&lt;/&gt; file or
+      the corresponding environment variable on the standby.
+      For example, if the primary is running on host IP<br/>&lt;literal&gt;192.168.1.50&lt;/&gt;,
+      port &lt;literal&gt;5432&lt;/literal&gt;, the superuser's name for replication is
+      &lt;literal&gt;foo&lt;/&gt;, and the password is &lt;literal&gt;foopass&lt;/&gt;, the<br/>administrator
+      can add the following line to the &lt;filename&gt;recovery.conf&lt;/&gt; file on the
+      standby.
+ 
+ &lt;programlisting&gt;
+ # The standby connects to the primary that is running on host 192.168.1.50
+ # and port 5432 as the user "foo" whose password is "foopass".
+ primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
+ &lt;/programlisting&gt;
+     &lt;/para&gt;
+    &lt;/sect2&gt;
+   &lt;/sect1&gt;
+ 
+   &lt;sect1 id="warm-standby-failover"&gt;
+    &lt;title&gt;Failover&lt;/title&gt;
+ 
+    &lt;para&gt;
+     If the primary server fails then the standby server should begin
+     failover procedures.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If the standby server fails then no failover need take place. If the
+     standby server can be restarted, even some time later, then the recovery
+     process can also be immediately restarted, taking advantage of
+     restartable recovery. If the standby server cannot be restarted, then a
+     full new standby server instance should be created.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If the primary server fails and the standby server becomes the
+     new primary, and then the old primary restarts, you must have
+     a mechanism for informing old primary that it is no longer the primary.<br/>This is
+     sometimes known as STONITH (Shoot The Other Node In The Head), which is
+     necessary to avoid situations where both systems think they are the
+     primary, which will lead to confusion and ultimately data loss.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Many failover systems use just two systems, the primary and the standby,
+     connected by some kind of heartbeat mechanism to continually verify the
+     connectivity between the two and the viability of the primary. It is
+     also possible to use a third system (called a witness server) to prevent
+     some cases of inappropriate failover, but the additional complexity
+     might not be worthwhile unless it is set up with sufficient care and
+     rigorous testing.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Once failover to the standby occurs, we have only a
+     single server in operation. This is known as a degenerate state.
+     The former standby is now the primary, but the former primary is down
+     and might stay down.  To return to normal operation we must
+     fully recreate a standby server,
+     either on the former primary system when it comes up, or on a third,
+     possibly new, system. Once complete the primary and standby can be
+     considered to have switched roles. Some people choose to use a third
+     server to provide backup for the new primary until the new standby
+     server is recreated,
+     though clearly this complicates the system configuration and
+     operational processes.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     So, switching from primary to standby server can be fast but requires
+     some time to re-prepare the failover cluster. Regular switching from
+     primary to standby is useful, since it allows regular downtime on
+     each system for maintenance. This also serves as a test of the
+     failover mechanism to ensure that it will really work when you need it.
+     Written administration procedures are advised.
+    &lt;/para&gt;
+   &lt;/sect1&gt;
+ 
+  &lt;sect1 id="hot-standby"&gt;
+   &lt;title&gt;Hot Standby&lt;/title&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;Hot Standby&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+    &lt;para&gt;
+     Hot Standby is the term used to describe the ability to connect to
+     the server and run queries while the server is in archive recovery. This
+     is useful for both log shipping replication and for restoring a backup
+     to an exact state with great precision.
+     The term Hot Standby also refers to the ability of the server to move
+     from recovery through to normal running while users continue running
+     queries and/or continue their connections.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Running queries in recovery is in many ways the same as normal running
+     though there are a large number of usage and administrative points
+     to note.
+    &lt;/para&gt;
+ 
+   &lt;sect2 id="hot-standby-users"&gt;
+    &lt;title&gt;User's Overview&lt;/title&gt;
+ 
+    &lt;para&gt;
+     Users can connect to the database while the server is in recovery
+     and perform read-only queries. Read-only access to catalogs and views
+     will also occur as normal.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The data on the standby takes some time to arrive from the primary server
+     so there will be a measurable delay between primary and standby. Running<br/>the
+     same query nearly simultaneously on both primary and standby might<br/>therefore
+     return differing results. We say that data on the standby is eventually
+     consistent with the primary.
+     Queries executed on the standby will be correct with regard to the<br/>transactions
+     that had been recovered at the start of the query, or start of first<br/>statement,
+     in the case of serializable transactions. In comparison with the primary,
+     the standby returns query results that could have been obtained on the<br/>primary
+     at some exact moment in the past.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     When a transaction is started in recovery, the parameter
+     &lt;varname&gt;transaction_read_only&lt;/&gt; will be forced to be true, regardless of<br/>the
+     &lt;varname&gt;default_transaction_read_only&lt;/&gt; setting in<br/>&lt;filename&gt;postgresql.conf&lt;/&gt;.
+     It can't be manually set to false either. As a result, all transactions
+     started during recovery will be limited to read-only actions only. In all
+     other ways, connected sessions will appear identical to sessions
+     initiated during normal processing mode. There are no special commands
+     required to initiate a connection at this time, so all interfaces
+     work normally without change. After recovery finishes, the session
+     will allow normal read-write transactions at the start of the next
+     transaction, if these are requested.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Read-only here means "no writes to the permanent database tables".
+     There are no problems with queries that make use of transient sort and
+     work files.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The following actions are allowed
+ 
+     &lt;itemizedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Query access - SELECT, COPY TO including views and SELECT RULEs
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Cursor commands - DECLARE, FETCH, CLOSE,
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Parameters - SHOW, SET, RESET
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Transaction management commands
+         &lt;itemizedlist&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            BEGIN, END, ABORT, START TRANSACTION
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            SAVEPOINT, RELEASE, ROLLBACK TO SAVEPOINT
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            EXCEPTION blocks and other internal subtransactions
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+         &lt;/itemizedlist&gt;
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        LOCK TABLE, though only when explicitly in one of these modes:
+        ACCESS SHARE, ROW SHARE or ROW EXCLUSIVE.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Plans and resources - PREPARE, EXECUTE, DEALLOCATE, DISCARD
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Plugins and extensions - LOAD
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     These actions produce error messages
+ 
+     &lt;itemizedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Data Manipulation Language (DML) - INSERT, UPDATE, DELETE, COPY FROM,<br/>TRUNCATE.
+        Note that there are no allowed actions that result in a trigger
+        being executed during recovery.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Data Definition Language (DDL) - CREATE, DROP, ALTER, COMMENT.
+        This also applies to temporary tables currently because currently their
+        definition causes writes to catalog tables.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        SELECT ... FOR SHARE | UPDATE which cause row locks to be written
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        RULEs on SELECT statements that generate DML commands.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        LOCK TABLE, in short default form, since it requests ACCESS EXCLUSIVE<br/>MODE.
+        LOCK TABLE that explicitly requests a mode higher than ROW EXCLUSIVE<br/>MODE.
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Transaction management commands that explicitly set non-read only state
+         &lt;itemizedlist&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+             BEGIN READ WRITE,
+             START TRANSACTION READ WRITE
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+             SET TRANSACTION READ WRITE,
+             SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+          &lt;listitem&gt;
+           &lt;para&gt;
+            SET transaction_read_only = off
+           &lt;/para&gt;
+          &lt;/listitem&gt;
+         &lt;/itemizedlist&gt;
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        Two-phase commit commands - PREPARE TRANSACTION, COMMIT PREPARED,
+        ROLLBACK PREPARED because even read-only transactions need to write
+        WAL in the prepare phase (the first phase of two phase commit).
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        sequence update - nextval()
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;
+        LISTEN, UNLISTEN, NOTIFY since they currently write to system tables
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Note that current behaviour of read only transactions when not in
+     recovery is to allow the last two actions, so there are small and
+     subtle differences in behaviour between read-only transactions
+     run on standby and during normal running.
+     It is possible that the restrictions on LISTEN, UNLISTEN, NOTIFY and
+     temporary tables may be lifted in a future release, if their internal
+     implementation is altered to make this possible.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If failover or switchover occurs the database will switch to normal
+     processing mode. Sessions will remain connected while the server
+     changes mode. Current transactions will continue, though will remain
+     read-only. After recovery is complete, it will be possible to initiate
+     read-write transactions.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Users will be able to tell whether their session is read-only by
+     issuing SHOW transaction_read_only.  In addition a set of
+     functions &lt;xref linkend="functions-recovery-info-table"&gt; allow users to
+     access information about Hot Standby. These allow you to write
+     functions that are aware of the current state of the database. These
+     can be used to monitor the progress of recovery, or to allow you to
+     write complex programs that restore the database to particular states.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In recovery, transactions will not be permitted to take any table lock
+     higher than RowExclusiveLock. In addition, transactions may never assign
+     a TransactionId and may never write WAL.
+     Any &lt;command&gt;LOCK TABLE&lt;/&gt; command that runs on the standby and requests
+     a specific lock mode higher than ROW EXCLUSIVE MODE will be rejected.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In general queries will not experience lock conflicts with the database
+     changes made by recovery. This is becase recovery follows normal
+     concurrency control mechanisms, known as &lt;acronym&gt;MVCC&lt;/&gt;. There are
+     some types of change that will cause conflicts, covered in the following
+     section.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-conflict"&gt;
+    &lt;title&gt;Handling query conflicts&lt;/title&gt;
+ 
+    &lt;para&gt;
+     The primary and standby nodes are in many ways loosely connected. Actions
+     on the primary will have an effect on the standby. As a result, there is
+     potential for negative interactions or conflicts between them. The easiest
+     conflict to understand is performance: if a huge data load is taking place
+     on the primary then this will generate a similar stream of WAL records on<br/>the
+     standby, so standby queries may contend for system resources, such as I/O.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     There are also additional types of conflict that can occur with Hot<br/>Standby.
+     These conflicts are &lt;emphasis&gt;hard conflicts&lt;/&gt; in the sense that we may
+     need to cancel queries and in some cases disconnect sessions to resolve<br/>them.
+     The user is provided with a number of optional ways to handle these
+     conflicts, though we must first understand the possible reasons behind a<br/>conflict.
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Access Exclusive Locks from primary node, including both explicit
+          LOCK commands and various kinds of DDL action
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Dropping tablespaces on the primary while standby queries are using
+          those tablespaces for temporary work files (work_mem overflow)
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Dropping databases on the primary while users are connected to that
+          database on the standby.
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Waiting to acquire buffer cleanup locks
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Early cleanup of data still visible to the current query's snapshot
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Some WAL redo actions will be for DDL actions. These DDL actions are
+     repeating actions that have already committed on the primary node, so
+     they must not fail on the standby node. These DDL locks take priority
+     and will automatically *cancel* any read-only transactions that get in
+     their way, after a grace period. This is similar to the possibility of
+     being canceled by the deadlock detector, but in this case the standby
+     process always wins, since the replayed actions must not fail. This
+     also ensures that replication doesn't fall behind while we wait for a
+     query to complete. Again, we assume that the standby is there for high
+     availability purposes primarily.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     An example of the above would be an Administrator on Primary server
+     runs a &lt;command&gt;DROP TABLE&lt;/&gt; on a table that's currently being queried
+     in the standby server.
+     Clearly the query cannot continue if we let the &lt;command&gt;DROP TABLE&lt;/&gt;
+     proceed. If this situation occurred on the primary, the &lt;command&gt;DROP<br/>TABLE&lt;/&gt;
+     would wait until the query has finished. When the query is on the standby
+     and the &lt;command&gt;DROP TABLE&lt;/&gt; is on the primary, the primary doesn't have
+     information about which queries are running on the standby and so the<br/>query
+     does not wait on the primary. The WAL change records come through to the
+     standby while the standby query is still running, causing a conflict.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The most common reason for conflict between standby queries and WAL redo<br/>is
+     "early cleanup". Normally, &lt;productname&gt;PostgreSQL&lt;/&gt; allows cleanup of<br/>old
+     row versions when there are no users who may need to see them to ensure<br/>correct
+     visibility of data (the heart of MVCC). If there is a standby query that<br/>has
+     been running for longer than any query on the primary then it is possible
+     for old row versions to be removed by either a vacuum or HOT. This will
+     then generate WAL records that, if applied, would remove data on the
+     standby that might *potentially* be required by the standby query.
+     In more technical language, the primary's xmin horizon is later than
+     the standby's xmin horizon, allowing dead rows to be removed.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Experienced users should note that both row version cleanup and row<br/>version
+     freezing will potentially conflict with recovery queries. Running a
+     manual &lt;command&gt;VACUUM FREEZE&lt;/&gt; is likely to cause conflicts even on<br/>tables
+     with no updated or deleted rows.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     We have a number of choices for resolving query conflicts.  The default
+     is that we wait and hope the query completes. The server will wait
+     automatically until the lag between primary and standby is at most
+     &lt;varname&gt;max_standby_delay&lt;/&gt; seconds. Once that grace period expires,
+     we take one of the following actions:
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          If the conflict is caused by a lock, we cancel the conflicting<br/>standby
+          transaction immediately. If the transaction is idle-in-transaction
+          then currently we abort the session instead, though this may change
+          in the future.
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+ 
+        &lt;listitem&gt;
+         &lt;para&gt;
+          If the conflict is caused by cleanup records we tell the standby<br/>query
+          that a conflict has occurred and that it must cancel itself to avoid<br/>the
+          risk that it silently fails to read relevant data because
+          that data has been removed. (This is regrettably very similar to the
+          much feared and iconic error message "snapshot too old"). Some<br/>cleanup
+          records only cause conflict with older queries, though some types of
+          cleanup record affect all queries.
+         &lt;/para&gt;
+ 
+         &lt;para&gt;
+          If cancellation does occur, the query and/or transaction can always
+          be re-executed. The error is dynamic and will not necessarily occur
+          the same way if the query is executed again.
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;varname&gt;max_standby_delay&lt;/&gt; is set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
+     The parameter applies to the server as a whole so if the delay is all used
+     up by a single query then there may be little or no waiting for queries<br/>that
+     follow immediately, though they will have benefited equally from the<br/>initial
+     waiting period. The server may take time to catch up again before the<br/>grace
+     period is available again, though if there is a heavy and constant stream
+     of conflicts it may seldom catch up fully.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Users should be clear that tables that are regularly and heavily updated<br/>on
+     primary server will quickly cause cancellation of longer running queries<br/>on
+     the standby. In those cases &lt;varname&gt;max_standby_delay&lt;/&gt; can be
+     considered somewhat but not exactly the same as setting
+     &lt;varname&gt;statement_timeout&lt;/&gt;.
+     &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Other remedial actions exist if the number of cancellations is<br/>unacceptable.
+     The first option is to connect to primary server and keep a query active
+     for as long as we need to run queries on the standby. This guarantees that
+     a WAL cleanup record is never generated and we don't ever get query
+     conflicts as described above. This could be done using contrib/dblink
+     and pg_sleep(), or via other mechanisms. If you do this, you should note
+     that this will delay cleanup of dead rows by vacuum or HOT and many
+     people may find this undesirable. However, we should remember that
+     primary and standby nodes are linked via the WAL, so this situation is no
+     different to the case where we ran the query on the primary node itself
+     except we have the benefit of off-loading the execution onto the standby.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     It is also possible to set &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; on the<br/>primary
+     to defer the cleanup of records by autovacuum, vacuum and HOT. This may<br/>allow
+     more time for queries to execute before they are cancelled on the standby,
+     without the need for setting a high &lt;varname&gt;max_standby_delay&lt;/&gt;.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Three-way deadlocks are possible between AccessExclusiveLocks arriving<br/>from
+     the primary, cleanup WAL records that require buffer cleanup locks and
+     user requests that are waiting behind replayed AccessExclusiveLocks.<br/>Deadlocks
+     are resolved by time-out when we exceed &lt;varname&gt;max_standby_delay&lt;/&gt;.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Dropping tablespaces or databases is discussed in the administrator's
+     section since they are not typical user situations.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-admin"&gt;
+    &lt;title&gt;Administrator's Overview&lt;/title&gt;
+ 
+    &lt;para&gt;
+     If there is a &lt;filename&gt;recovery.conf&lt;/&gt; file present the server will<br/>start
+     in Hot Standby mode by default, though &lt;varname&gt;recovery_connections&lt;/&gt;<br/>can
+     be disabled via &lt;filename&gt;postgresql.conf&lt;/&gt;, if required. The server may<br/>take
+     some time to enable recovery connections since the server must first<br/>complete
+     sufficient recovery to provide a consistent state against which queries
+     can run before enabling read only connections. Look for these messages
+     in the server logs
+ 
+ &lt;programlisting&gt;
+ LOG:  initializing recovery connections
+ 
+ ... then some time later ...
+ 
+ LOG:  consistent recovery state reached
+ LOG:  database system is ready to accept read only connections
+ &lt;/programlisting&gt;
+ 
+     Consistency information is recorded once per checkpoint on the primary, as<br/>long
+     as &lt;varname&gt;recovery_connections&lt;/&gt; is enabled (on the primary). If this<br/>parameter
+     is disabled, it will not be possible to enable recovery connections on the<br/>standby.
+     The consistent state can also be delayed in the presence of both of these<br/>conditions
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          a write transaction has more than 64 subtransactions
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          very long-lived write transactions
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+ 
+     If you are running file-based log shipping ("warm standby"), you may need
+     to wait until the next WAL file arrives, which could be as long as the
+     &lt;varname&gt;archive_timeout&lt;/&gt; setting on the primary.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The setting of some parameters on the standby will need reconfiguration
+     if they have been changed on the primary. The value on the standby must
+     be equal to or greater than the value on the primary. If these parameters
+     are not set high enough then the standby will not be able to track work
+     correctly from recovering transactions. If these values are set too low<br/>the
+     the server will halt. Higher values can then be supplied and the server
+     restarted to begin recovery again.
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          &lt;varname&gt;max_connections&lt;/&gt;
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          &lt;varname&gt;max_prepared_transactions&lt;/&gt;
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          &lt;varname&gt;max_locks_per_transaction&lt;/&gt;
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     It is important that the administrator consider the appropriate setting
+     of &lt;varname&gt;max_standby_delay&lt;/&gt;, set in &lt;filename&gt;postgresql.conf&lt;/&gt;.
+     There is no optimal setting and should be set according to business
+     priorities. For example if the server is primarily tasked as a High
+     Availability server, then you may wish to lower
+     &lt;varname&gt;max_standby_delay&lt;/&gt; or even set it to zero, though that is a
+     very aggressive setting. If the standby server is tasked as an additional
+     server for decision support queries then it may be acceptable to set this
+     to a value of many hours (in seconds).
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Transaction status "hint bits" written on primary are not WAL-logged,
+     so data on standby will likely re-write the hints again on the standby.
+     Thus the main database blocks will produce write I/Os even though
+     all users are read-only; no changes have occurred to the data values
+     themselves.  Users will be able to write large sort temp files and
+     re-generate relcache info files, so there is no part of the database
+     that is truly read-only during hot standby mode. There is no restriction
+     on the use of set returning functions, or other users of<br/>tuplestore/tuplesort
+     code. Note also that writes to remote databases will still be possible,
+     even though the transaction is read-only locally.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     The following types of administrator command are not accepted
+     during recovery mode
+ 
+       &lt;itemizedlist&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Data Definition Language (DDL) - e.g. CREATE INDEX
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Privilege and Ownership - GRANT, REVOKE, REASSIGN
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+        &lt;listitem&gt;
+         &lt;para&gt;
+          Maintenance commands - ANALYZE, VACUUM, CLUSTER, REINDEX
+         &lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/itemizedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Note again that some of these commands are actually allowed during
+     "read only" mode transactions on the primary.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     As a result, you cannot create additional indexes that exist solely
+     on the standby, nor can statistics that exist solely on the standby.
+     If these administrator commands are needed they should be executed
+     on the primary so that the changes will propagate through to the
+     standby.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;function&gt;pg_cancel_backend()&lt;/&gt; will work on user backends, but not the
+     Startup process, which performs recovery. pg_stat_activity does not
+     show an entry for the Startup process, nor do recovering transactions
+     show as active. As a result, pg_prepared_xacts is always empty during
+     recovery. If you wish to resolve in-doubt prepared transactions
+     then look at pg_prepared_xacts on the primary and issue commands to
+     resolve those transactions there.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     pg_locks will show locks held by backends as normal. pg_locks also shows
+     a virtual transaction managed by the Startup process that owns all
+     AccessExclusiveLocks held by transactions being replayed by recovery.
+     Note that Startup process does not acquire locks to
+     make database changes and thus locks other than AccessExclusiveLocks
+     do not show in pg_locks for the Startup process, they are just presumed
+     to exist.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;productname&gt;check_pgsql&lt;/&gt; will work, but it is very simple.
+     &lt;productname&gt;check_postgres&lt;/&gt; will also work, though many some actions
+     could give different or confusing results.
+     e.g. last vacuum time will not be maintained for example, since no
+     vacuum occurs on the standby (though vacuums running on the primary do
+     send their changes to the standby).
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     WAL file control commands will not work during recovery
+     e.g. &lt;function&gt;pg_start_backup&lt;/&gt;, &lt;function&gt;pg_switch_xlog&lt;/&gt; etc..
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Dynamically loadable modules work, including pg_stat_statements.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Advisory locks work normally in recovery, including deadlock detection.
+     Note that advisory locks are never WAL logged, so it is not possible for
+     an advisory lock on either the primary or the standby to conflict with WAL
+     replay. Nor is it possible to acquire an advisory lock on the primary
+     and have it initiate a similar advisory lock on the standby. Advisory
+     locks relate only to a single server on which they are acquired.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Trigger-based replication systems such as &lt;productname&gt;Slony&lt;/&gt;,
+     &lt;productname&gt;Londiste&lt;/&gt; and &lt;productname&gt;Bucardo&lt;/&gt; won't run on the
+     standby at all, though they will run happily on the primary server as
+     long as the changes are not sent to standby servers to be applied.
+     WAL replay is not trigger-based so you cannot relay from the
+     standby to any system that requires additional database writes or
+     relies on the use of triggers.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     New oids cannot be assigned, though some &lt;acronym&gt;UUID&lt;/&gt; generators may<br/>still
+     work as long as they do not rely on writing new status to the database.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Currently, temp table creation is not allowed during read only
+     transactions, so in some cases existing scripts will not run correctly.
+     It is possible we may relax that restriction in a later release. This is
+     both a SQL Standard compliance issue and a technical issue.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     &lt;command&gt;DROP TABLESPACE&lt;/&gt; can only succeed if the tablespace is empty.
+     Some standby users may be actively using the tablespace via their
+     &lt;varname&gt;temp_tablespaces&lt;/&gt; parameter. If there are temp files in the
+     tablespace we currently cancel all active queries to ensure that temp
+     files are removed, so that we can remove the tablespace and continue with
+     WAL replay.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Running &lt;command&gt;DROP DATABASE&lt;/&gt;, &lt;command&gt;ALTER DATABASE ... SET<br/>TABLESPACE&lt;/&gt;,
+     or &lt;command&gt;ALTER DATABASE ... RENAME&lt;/&gt; on primary will generate a log<br/>message
+     that will cause all users connected to that database on the standby to be
+     forcibly disconnected. This action occurs immediately, whatever the<br/>setting of
+     &lt;varname&gt;max_standby_delay&lt;/&gt;.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     In normal running, if you issue &lt;command&gt;DROP USER&lt;/&gt; or &lt;command&gt;DROP<br/>ROLE&lt;/&gt;
+     for a role with login capability while that user is still connected then
+     nothing happens to the connected user - they remain connected. The user<br/>cannot
+     reconnect however. This behaviour applies in recovery also, so a
+     &lt;command&gt;DROP USER&lt;/&gt; on the primary does not disconnect that user on the<br/>standby.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Stats collector is active during recovery. All scans, reads, blocks,
+     index usage etc will all be recorded normally on the standby. Replayed
+     actions will not duplicate their effects on primary, so replaying an
+     insert will not increment the Inserts column of pg_stat_user_tables.
+     The stats file is deleted at start of recovery, so stats from primary
+     and standby will differ; this is considered a feature not a bug.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Autovacuum is not active during recovery, though will start normally
+     at the end of recovery.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Background writer is active during recovery and will perform
+     restartpoints (similar to checkpoints on primary) and normal block
+     cleaning activities. The &lt;command&gt;CHECKPOINT&lt;/&gt; command is accepted during<br/>recovery,
+     though performs a restartpoint rather than a new checkpoint.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-parameters"&gt;
+    &lt;title&gt;Hot Standby Parameter Reference&lt;/title&gt;
+ 
+    &lt;para&gt;
+     Various parameters have been mentioned above in the &lt;xref<br/>linkend="hot-standby-admin"&gt;
+     and &lt;xref linkend="hot-standby-conflict"&gt; sections.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     On the primary, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
+     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; can be used to enable and control the
+     primary server to assist the successful configuration of Hot Standby<br/>servers.
+     &lt;varname&gt;max_standby_delay&lt;/&gt; has no effect if set on the primary.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     On the standby, parameters &lt;varname&gt;recovery_connections&lt;/&gt; and
+     &lt;varname&gt;max_standby_delay&lt;/&gt; can be used to enable and control Hot<br/>Standby.
+     standby server to assist the successful configuration of Hot Standby<br/>servers.
+     &lt;varname&gt;vacuum_defer_cleanup_age&lt;/&gt; has no effect during recovery.
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+   &lt;sect2 id="hot-standby-caveats"&gt;
+    &lt;title&gt;Caveats&lt;/title&gt;
+ 
+    &lt;para&gt;
+     At this writing, there are several limitations of Hot Standby.
+     These can and probably will be fixed in future releases:
+ 
+   &lt;itemizedlist&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      Operations on hash indexes are not presently WAL-logged, so
+      replay will not update these indexes.  Hash indexes will not be
+      used for query plans during recovery.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      Full knowledge of running transactions is required before snapshots
+      may be taken. Transactions that take use large numbers of subtransactions
+      (currently greater than 64) will delay the start of read only
+      connections until the completion of the longest running write<br/>transaction.
+      If this situation occurs explanatory messages will be sent to server log.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      Valid starting points for recovery connections are generated at each
+      checkpoint on the master. If the standby is shutdown while the master
+      is in a shutdown state it may not be possible to re-enter Hot Standby
+      until the primary is started up so that it generates further starting
+      points in the WAL logs. This is not considered a serious issue
+      because the standby is usually switched into the primary role while
+      the first node is taken down.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+    &lt;listitem&gt;
+     &lt;para&gt;
+      At the end of recovery, AccessExclusiveLocks held by prepared<br/>transactions
+      will require twice the normal number of lock table entries. If you plan
+      on running either a large number of concurrent prepared transactions
+      that normally take AccessExclusiveLocks, or you plan on having one
+      large transaction that takes many AccessExclusiveLocks then you are
+      advised to select a larger value of<br/>&lt;varname&gt;max_locks_per_transaction&lt;/&gt;,
+      up to, but never more than twice the value of the parameter setting on
+      the primary server in rare extremes. You need not consider this at all if
+      your setting of &lt;varname&gt;max_prepared_transactions&lt;/&gt; is &lt;literal&gt;0&lt;/&gt;.
+     &lt;/para&gt;
+    &lt;/listitem&gt;
+   &lt;/itemizedlist&gt;
+ 
+    &lt;/para&gt;
+   &lt;/sect2&gt;
+ 
+  &lt;/sect1&gt;
+ 
+   &lt;sect1 id="backup-incremental-updated"&gt;
+    &lt;title&gt;Incrementally Updated Backups&lt;/title&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;incrementally updated backups&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+   &lt;indexterm zone="high-availability"&gt;
+    &lt;primary&gt;change accumulation&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
+    &lt;para&gt;
+     In a warm standby configuration, it is possible to offload the expense of
+     taking periodic base backups from the primary server; instead base backups
+     can be made by backing
+     up a standby server's files.  This concept is generally known as
+     incrementally updated backups, log change accumulation, or more simply,
+     change accumulation.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     If we take a file system backup of the standby server's data
+     directory while it is processing
+     logs shipped from the primary, we will be able to reload that backup and
+     restart the standby's recovery process from the last restart point.
+     We no longer need to keep WAL files from before the standby's restart<br/>point.
+     If we need to recover, it will be faster to recover from the incrementally
+     updated backup than from the original base backup.
+    &lt;/para&gt;
+ 
+    &lt;para&gt;
+     Since the standby server is not &lt;quote&gt;live&lt;/&gt;, it is not possible to
+     use &lt;function&gt;pg_start_backup()&lt;/&gt; and &lt;function&gt;pg_stop_backup()&lt;/&gt;
+     to manage the backup process; it will be up to you to determine how
+     far back you need to keep WAL segment files to have a recoverable
+     backup.  You can do this by running &lt;application&gt;pg_controldata&lt;/&gt;
+     on the standby server to inspect the control file and determine the
+     current checkpoint WAL location, or by using the
+     &lt;varname&gt;log_checkpoints&lt;/&gt; option to print values to the standby's
+     server log.
+    &lt;/para&gt;
+   &lt;/sect1&gt;
+ 
  &lt;/chapter&gt;
</footer><footer type="noise" depth="0">
</footer><footer type="list-management" depth="0">-- 
Sent via pgsql-hackers mailing list (<email>pgsql-hackers@postgresql.org</email>)
To make changes to your subscription:
<url>http://www.postgresql.org/mailpref/pgsql-hackers</url>
</footer></body></message>