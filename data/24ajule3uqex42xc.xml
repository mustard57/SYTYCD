<message message-id="a05200f00bd1c204399b8@[81.103.217.9]" list="org.python.pythonmac-sig" id="24ajule3uqex42xc" type="general" date="2004-07-15T17:44:14" year="2004-01-01" year-month="2004-07-01" year-month-day="2004-07-15" thread-id="dpx3evmugesnbztb"><headers><envelope-from-line>From hengist.podd@virgin.net  Thu Jul 15 17:43:52 2004</envelope-from-line><from personal="has" address="hengist.podd@virgin.net">has &lt;hengist.podd@virgin.net&gt;</from><subject normal="[Pythonmac-SIG] Re: improving appscript architecture">[Pythonmac-SIG] Re: improving appscript architecture</subject><date>Thu Jul 15 17:44:14 2004</date><in-reply-to>&lt;83650530-D1E9-11D8-AD24-000D934FF6B4@cwi.nl&gt;</in-reply-to><references>&lt;20040706211902.3C3DA1E4017@bag.python.org&gt;
	&lt;40EB2340.3000503@san.rr.com&gt;	&lt;a05200f13bd1370cd6b36@[81.103.217.9]&gt;
	&lt;83650530-D1E9-11D8-AD24-000D934FF6B4@cwi.nl&gt;</references><message-id>a05200f00bd1c204399b8@[81.103.217.9]</message-id><content-type>text/plain; charset=iso-8859-1</content-type><mime-version>1.0</mime-version></headers><normalized-references><normalized-message-id>a05200f00bd1c204399b8@[81.103.217.9]</normalized-message-id><normalized-in-reply-to>83650530-D1E9-11D8-AD24-000D934FF6B4@cwi.nl</normalized-in-reply-to><normalized-reference>20040706211902.3C3DA1E4017@bag.python.org</normalized-reference><normalized-reference>40EB2340.3000503@san.rr.com</normalized-reference><normalized-reference>a05200f13bd1370cd6b36@[81.103.217.9]</normalized-reference><normalized-reference>83650530-D1E9-11D8-AD24-000D934FF6B4@cwi.nl</normalized-reference></normalized-references><body type="text/plain; charset=iso-8859-1"><para depth="0">Jack wrote:

</para><quote depth="1"><quote depth="2"><quotepara depth="2">Given that I'm angling for appscript's eventual inclusion in the 
standard MacPython library, the code needs to be grokkable and 
maintainable by others (lest I be hit by the Proverbial Bus 
someday).
</quotepara></quote><quotepara depth="1">
I'm very interested in understanding this (as I'll probably be the 
default maintainer if it gets included in the standard distribution) 
but I have tried a couple of times to understand your message and I 
simply can't seem to grok it.
</quotepara></quote><para depth="0">
Can't blame ya. I wrote that stuff in a hurry before zipping off for 
the week; I don't think I could understand it now either. :p

</para><quote depth="1"><quotepara depth="1">Could you come up with a more concrete example of what the problem 
is that you're trying to solve? Or, alternatively, explain the 
architecture that you're using for appscript at the moment.
</quotepara></quote><para depth="0">
For now I'll answer the latter.

</para><para depth="0">This rebuild gets rid of appscript 0.5.0's monolithic design. While 
it works, everything is dependent on everything else so it doesn't 
adapt well to multiple uses. The new architecture consists of lots of 
small, simple, loosely-coupled packages that can be combined however 
you like. The two most basic packages are:

</para><para depth="0">- aecodecs -- convert Python data to/from Apple event data (i.e. this 
package is roughly equivalent to Python's aepack module, minus all 
the object specifier-related stuff which is now dealt with separately)

</para><para depth="0">- AEM -- creates AEAddressDescs and sends Apple events (i.e. roughly 
equivalent to the old aetools)

</para><para depth="0">I'll probably rename AEM to aesend at some point. I'll then rework 
the MiniAEFrame module to create a new package, aereceive, as a 
complement to aesend. These three packages should cover all your 
basic Apple event needs: client applications can send basic AEs using 
aecodecs and aesend; server applications would use aecodecs and 
aereceive.

</para><para depth="0">The next layer consists of a single package:

</para><para depth="0">- objspec -- extends aecodecs with support for object specifiers (raw 
AE codes only)

</para><para depth="0">This package wraps and re-exports aecodecs, adding support for object 
specifiers as it does so. This lets you construct object specifiers 
using raw 4-letter codes. Sort of what the old aetypes module does, 
but with a superior API. Whereas aetypes provides a bunch of loose 
classes that directly represent the various AE types used to 
construct object specifiers and leaves the user to assemble them in 
the right order, objspec lets you construct references via chained 
method calls. e.g. To refer to the text property of document 1 of an 
application:

</para><para depth="0">   ref = objspec.app.elems('docu').byindex(1).prop('ctxt')

</para><para depth="0">Basically the same 'smart' approach used by appscript 0.5.0, but 
without the syntactic sugar and OSA terminology support. This API may 
be used directly by Python application developers who want to 
manipulate object specifiers without the extra overhead of working 
with aetes. This is the package I want to make easily extensible so 
other packages can merge additional functionality like syntax sugar 
and sanity checking to give application scripters the full 'appscript 
experience', or automatic name-attribute bindings and other hooks to 
help developers writing Python-based applications to implement 
scriptability.

</para><para depth="0">Other stuff I'm working on:

</para><para depth="0">- osaterms -- the new aete parser (now provides a more flexible 
SAX-style API), plus some useful tools that use this parser (a basic 
aete-to-documentation renderer, and a simple code generator for 
converting application terminology into Carbon.AppleEvents-like 
contstants modules)

</para><para depth="0">- aslite -- 'appscript lite' - extends objspec to allow object 
specifiers to be constructed using application terminology obtained 
via osaterms

</para><para depth="0">The aslite package is mostly just a testbed for seeing how objspec is 
panning out extensibility-wise. (Answer: not very well so far.) What 
I'd really like to be able to do is duplicate the entire objspec 
module, then insert the new behaviours directly into the duplicate's 
classes. (Prototype-based OO languages make this kind of powerful 
object extension dead easy, which is why I get a bit frustrated at 
class-based OO languages which are simultaneously more complex and 
less flexible.)

</para><quote depth="1"><quotepara depth="1">The nice side of the old gensuitemodule architecture was that it was 
nicely compartmentalized, so you could really understand it a bit at 
a time: the C-stuff is completely self-contained, as is aepack. 
Aetypes had a bit more complexity, but it was all basically 
localized. Gensuitemodule is standalone, and the two-pass 
architecture made it also reasonably easy to understand.
</quotepara></quote><para depth="0">
Yeah, the new appscript architecture is meant to provide the same 
kind of compartmentalisation, eliminating heavy coupling, circular 
references, etc. that prevent the old appscript's constituent parts 
being useful/understandable/testable outside of the complete package. 
(Actually, I think even the old gsm architecture is more tightly 
bound together than the new appscript.)

</para><quote depth="1"><quotepara depth="1">And the generated packages had (at the price of being incorrect:-) 
also only limited global complexity (the name lookups being the main 
one), with only limited dependency on magic implemented by aetypes.
</quotepara></quote><para depth="0">
appscript did away with glues completely. There's really no value in 
creating proxy classes based on an application's aete: it's just a 
way of sugaring the API used to construct object specifiers so it 
looks like familiar conventional OO references rather than exotic 
queries, and Python lets you achieve that via __getattr__. (I believe 
there's other Python-to-X bridges that use the same basic technique 
to dress up their query-based interfaces.)

</para><para depth="0">The downside of sugar is it obscures mechanics, which is a nuisance 
for someone like yourself trying to figure out how the implementation 
works (this is just as true of glues, which obscure the query-centric 
nature of object specifiers). Objspec implements the query-building 
API sans sugar, so should be reasonably easy to follow once you map 
out the inheritance hierarchy used to compose specifier behaviours.

</para><footer type="signature" hash="8795745246658926666" depth="0">Hope that explains the basic architecture; if it has, we can start 
discussing the objspec extensibility problem. Let me know.

</footer><footer type="signature" hash="4375007157118826096" depth="0">has
-- 
<url>http://freespace.virgin.net/hamish.sanderson/</url>
</footer></body></message>