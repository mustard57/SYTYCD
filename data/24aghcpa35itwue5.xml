<message message-id="42111E56.3040600@apache.org" list="org.apache.lucene.java-dev" id="24aghcpa35itwue5" type="development" date="2005-02-14T13:55:34-08:00" year="2005-01-01" year-month="2005-02-01" year-month-day="2005-02-14" thread-id="d7qvdom2qsihntrw"><headers><envelope-from-line>From lucene-dev-return-9390-apmail-jakarta-lucene-dev-archive=jakarta.apache.org@jakarta.apache.org Mon Feb 14 21:55:39 2005</envelope-from-line><from personal="Doug Cutting" address="cutting@apache.org">Doug Cutting &lt;cutting@apache.org&gt;</from><to personal="Lucene Developers List" address="lucene-dev@jakarta.apache.org">Lucene Developers List &lt;lucene-dev@jakarta.apache.org&gt;</to><subject normal="Transactional Directories">Re: Transactional Directories</subject><return-path>lucene-dev-return-9390-apmail-jakarta-lucene-dev-archive=jakarta.apache.org@jakarta.apache.org</return-path><delivered-to>apmail-jakarta-lucene-dev-archive@www.apache.org</delivered-to><received>(qmail 13966 invoked from network); 14 Feb 2005 21:55:39 -0000</received><received>from hermes.apache.org (HELO mail.apache.org) (209.237.227.199)
  by minotaur-2.apache.org with SMTP; 14 Feb 2005 21:55:39 -0000</received><received>(qmail 70362 invoked by uid 500); 14 Feb 2005 21:55:37 -0000</received><delivered-to>apmail-jakarta-lucene-dev-archive@jakarta.apache.org</delivered-to><received>(qmail 70337 invoked by uid 500); 14 Feb 2005 21:55:37 -0000</received><mailing-list>contact lucene-dev-help@jakarta.apache.org; run by ezmlm</mailing-list><precedence>bulk</precedence><list-unsubscribe>&lt;mailto:lucene-dev-unsubscribe@jakarta.apache.org&gt;</list-unsubscribe><list-subscribe>&lt;mailto:lucene-dev-subscribe@jakarta.apache.org&gt;</list-subscribe><list-help>&lt;mailto:lucene-dev-help@jakarta.apache.org&gt;</list-help><list-post>&lt;mailto:lucene-dev@jakarta.apache.org&gt;</list-post><list-id>"Lucene Developers List" &lt;lucene-dev.jakarta.apache.org&gt;</list-id><reply-to>"Lucene Developers List" &lt;lucene-dev@jakarta.apache.org&gt;</reply-to><delivered-to>mailing list lucene-dev@jakarta.apache.org</delivered-to><received>(qmail 70314 invoked by uid 99); 14 Feb 2005 21:55:37 -0000</received><x-asf-spam-status>No, hits=0.0 required=10.0
	tests=</x-asf-spam-status><x-spam-check-by>apache.org</x-spam-check-by><received-spf>neutral (hermes.apache.org: local policy)</received-spf><received>from rwcrmhc11.comcast.net (HELO rwcrmhc11.comcast.net) (204.127.198.35)
  by apache.org (qpsmtpd/0.28) with ESMTP; Mon, 14 Feb 2005 13:55:36 -0800</received><received>from [192.168.168.81] (c-24-5-160-217.client.comcast.net[24.5.160.217])
          by comcast.net (rwcrmhc11) with ESMTP
          id &lt;2005021421553401300f9abee&gt;; Mon, 14 Feb 2005 21:55:34 +0000</received><message-id>42111E56.3040600@apache.org</message-id><date>Mon, 14 Feb 2005 13:55:34 -0800</date><user-agent>Mozilla Thunderbird 0.9 (X11/20041127)</user-agent><x-accept-language>en-us, en</x-accept-language><mime-version>1.0</mime-version><references>&lt;20050214180223.40088.qmail@web50203.mail.yahoo.com&gt;</references><in-reply-to>&lt;20050214180223.40088.qmail@web50203.mail.yahoo.com&gt;</in-reply-to><content-type>text/plain; charset=ISO-8859-1; format=flowed</content-type><content-transfer-encoding>7bit</content-transfer-encoding><x-virus-checked>Checked</x-virus-checked><x-spam-rating>minotaur-2.apache.org 1.6.2 0/1000/N</x-spam-rating></headers><normalized-references><normalized-message-id>42111E56.3040600@apache.org</normalized-message-id><normalized-in-reply-to>20050214180223.40088.qmail@web50203.mail.yahoo.com</normalized-in-reply-to><normalized-reference>20050214180223.40088.qmail@web50203.mail.yahoo.com</normalized-reference></normalized-references><body type="text/plain; charset=iso-8859-1; format=flowed"><para depth="0">
Oscar Picasso wrote:
</para><quote depth="1"><quotepara depth="1">Hi,

</quotepara><quotepara depth="1">I am currently implementing a Directory backed by a Berkeley DB that I am
willing to release as an open source project.

</quotepara><quotepara depth="1">Besides the internal implementation, it differs from the one in the sandbox in
that it is implemented with the Berkeley DB Java Edition.

</quotepara><quotepara depth="1">Using the Java Edition allows an easier distribution as you just need to add a
single jar in your classpath and you have a fully functional Berkeley DB
embedded in your application without the hassle of installing the C Berkeley
DB.

</quotepara><quotepara depth="1">While initially implemented with the Java Edition this Directory can easily be
ported to a Berkeley DB C edition or a Berkeley DB XML (for example to use
Berkeley DB XML + Lucene as the base for a document management system).

</quotepara><quotepara depth="1">This implementation works fine and I am quite happy with its speed.

</quotepara><quotepara depth="1">There is still an important problem I face and it has to do with how to deal
with some transactions. After all, the purpose of a Berkeley implementation, or
a JDBC one for that matter, is its ability to use transactions.

</quotepara><quotepara depth="1">After looking at the Andy Varga code, it seems that the implementation in the
sandbox face the same problem (correct me if I am wrong). I have also learn
that the JDBC directory was not implemented with transactions in mind.

</quotepara><quotepara depth="1">Here the problem. 

</quotepara><quotepara depth="1">If I do something like that:
-- case A --
&lt;pseudo-code&gt;
+begin transaction
 new IndexWriter
 create/update/delete objects in the database
 index.addDocument (related to the objects)
 indexWriter.close()
+commit
&lt;/pseudo-code&gt;

</quotepara><quotepara depth="1">Everything is fine. The operations are transactionally protected. You can even
do many writes/updates. As far as everything in enclosed by the pairs
begin-transaction/new-index-writer ... index-writer.close/commit everything is
properly undone is case of any operation fails insidde the transaction.

</quotepara><quotepara depth="1">For batch insertions the whole batch is rolled back but at least your object
database is consistent with the index.

</quotepara><quotepara depth="1">If you do mostly batch insertions and relatively few random individual
insertions. That's fine.

</quotepara><quotepara depth="1">However with a relatively high number of random insertions, the cost of the
"new IndexWriter / index.close()" performed for each insertion is two high.
Unfortunately this it is a common case for some kind of applications and it is
where a transactional directory would the most useful.

</quotepara><quotepara depth="1">In such a case you would like to do something like that:
-- case B --
&lt;pseudo-code&gt;
new IndexWriter
 ...
+begin transaction-1
 create/update/delete objects in the database
 index.addDocument (related to the objects)
+ commit
...
+begin transaction-2
 create/update/delete objects in the database
 index.addDocument (related to the objects)
+ commit
...
indexWriter.close()
&lt;/pseudo-code&gt;

</quotepara><quotepara depth="1">The benefits would be to protect individual insertions while avoiding the cost
of using each time a new IndexWriter.

</quotepara><quotepara depth="1">It doesn't work however. Here is my understanding. 

</quotepara><quotepara depth="1">Suppose that in case B, transaction-1 fails and transaction-2 succeeds.

</quotepara><quotepara depth="1">In that case the underlying database system rolls back all the writes done
during transaction-1 whether they were related to the objects stored in the
database or to the index (the writes done to the IndexOutput are also undone).
From the database point of view consistency is maintained between the stored
object and the index.

</quotepara><quotepara depth="1">The problem is that after transaction-1 Lucene still 'remembers' the segment(s)
it wrote during transaction-1. Later, Lucene might 'want' to perform some
operation based on these references (on merging the segments, I think) while
the underlying segment(s) files do not exist anymore. This is where an
Exception is thrown.

</quotepara><quotepara depth="1">The solution would be to instruct Lucene to 'forget' or undo any reference to
the segments created during transaction-1 in case of rollback;

</quotepara><quotepara depth="1">I have noticed that references to the segments are stored in a segmentInfos
map. I was thinking about removing the segmentsInfo map entries created during
transaction-1 in case of a rollback but I don't see if it's enough and/or
potentially dangerous.

</quotepara><quotepara depth="1">I would really appreciate any comment about this idea and also about my
understanding of the Lucene indexing process.

</quotepara><quotepara depth="1">If I/we could find a solution it would also benefit a JDBC Directory
implementation

</quotepara><quotepara depth="1">Thanks.

</quotepara><quotepara depth="1">Oscar

</quotepara><quotepara depth="1">P.S.: If and when my implementation is fully functional, is there a place in
the Lucene project where I could release it? (Maybe the sandbox).

</quotepara><quotefooter type="free-hosting" hash="2997445823789800285" depth="1">__________________________________ 
Do you Yahoo!? 
The all-new My Yahoo! - What will yours do?
<url>http://my.yahoo.com</url> 

</quotefooter><quotefooter type="list-management" hash="13658184913265832020" depth="1">---------------------------------------------------------------------
To unsubscribe, e-mail: <email>lucene-dev-unsubscribe@jakarta.apache.org</email>
For additional commands, e-mail: <email>lucene-dev-help@jakarta.apache.org</email>

</quotefooter></quote><footer type="list-management" depth="0">---------------------------------------------------------------------
To unsubscribe, e-mail: <email>lucene-dev-unsubscribe@jakarta.apache.org</email>
For additional commands, e-mail: <email>lucene-dev-help@jakarta.apache.org</email>

</footer></body></message>